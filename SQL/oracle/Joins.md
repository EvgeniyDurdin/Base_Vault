[Исходная статья](https://docs.oracle.com/en/database/oracle/oracle-database/21/tgsql/joins.html#GUID-5435FC78-D572-4CEE-A733-CDB1DB8E544B)

У СУБД ORACLE есть несколько оптимизаций для объединения наборов строк

### 1. Описание 
`join` объединяет данные ровно двух наборов строк, таких как таблицы или представления и возвращает одни набор строк.
`join` характеризуется наличием нескольких таблиц в `WHERE` (non-ANST) или `FROM ... JOIN` (ANSI). Всякий раз когда в `FROM` находятся несколько таблиц, Oracle выполняет `join`.
- `join condition` (условие соединения) - условие, которое сравнивает два источника строк с использованием выражения. База данных объединяет пары строк, каждая из которых содержит по одной строке из каждого источника строк, для которых условие равно true.
- `join elimination` (исключение соединения) - удаление избыточных таблиц из запроса. Таблица является избыточной, если на ее столбцы ссылаются только в предикатах объединения, и эти объединения гарантированно не будут ни фильтровать, ни расширять результирующие строки.
- `join predicate` (предикат соединения) - предикат в инструкции `WHERE` или `JOIN`, который объединяет столбцы двух таблиц.

### 1.2 Деревья соединений
Обычно дерево соединений представляется в виде перевернутой древовидной структуры.
Как показано на следующем рисунке, `table1` это левая таблица, а `table2` это правая таблица. Оптимизатор обрабатывает объединение слева направо. Например, если на этом рисунке изображено объединение вложенных циклов, то `table1` это внешний цикл, а `table2` - внутренний цикл.
![[SQL/Oracle/content/Oracle_9.2.1.png]]
Входом объединения может быть результирующий набор из предыдущего объединения. Если правым дочерним элементом каждого внутреннего узла дерева соединений является таблица, то дерево является **левым глубоким деревом соединений**, как показано в следующем примере. Большинство деревьев соединений оставлены глубокими соединениями.
![[Oracle_9.2.2.png]]
Если левым дочерним элементом каждого внутреннего узла дерева соединений является таблица, то дерево называется **правым глубоким деревом соединений**, как показано на следующей диаграмме.
![[Oracle_9.2.3.png]]
Если левый или правый дочерний элемент внутреннего узла дерева объединения может быть узлом объединения, тогда дерево называется **кустистым деревом соединения**. В следующем примере `table4` является правым дочерним элементом узла объединения, `table1` является левым дочерним элементом узла объединения и `table2` является левым дочерним элементом узла объединения.
![[Oracle_9.2.4.png]]

### 1.3 Как оптимизатор выбирает планы выполнения для объединений
При определении порядка и метода объединения целью оптимизатора является скорейшее уменьшение количества строк, чтобы он выполнял меньше работы в последующих инструкциях SQL.
Оптимизатор генерирует набор планов выполнения в соответствии с возможными порядками объединения, методами объединения и доступными путями доступа. Затем оптимизатор оценивает стоимость каждого плана и выбирает тот, которые имеет наименьшую стоимость. При выборе плана выполнения оптимизатор учитывает следующие факторы:
- сначала определяется приведет ли объединение одной или более таблиц к получению набора данных из одной строки. Оптимизатор распознает такие ситуации на основе `UNIQUE` и `PRIMARY KEY` ограничений в таблицах. Если такая ситуация существуют, то эти таблицы будут первыми в порядке объединения.
- 

## 2. Методы объединения
Метод объединения - это механизм для объединения двух источников строк.
В зависимости от статистики оптимизатор выбирает метод с наименьшей предполагаемой стоимостью. Как показано на рисунке, у каждого метода объединения есть два дочерних элемента: основной (также называемый внешним) источник строки и ведомый (также называемый внутренним) источник строки.
![[Oracle_9.2.5.png]]

### 2.1 Объединение Nested Loops
Вложенные циклы соединяют внешний набор данных с внутренним набором данных.
Для каждой строки во внешнем наборе данных, которая соответствует предикатам одной таблицы, база данных извлекает все строки во внутреннем наборе данных, которые удовлетворяют предикату объединения. Если индекс доступен, то база данных может использовать его для доступа к внутренним данным, установленным rowid.

#### 2.1.1 Когда оптимизатор использует объединение Nested Loops
Объединения с вложенными циклами полезны, когда: база данных объединяет небольшие подмножества данных, база данных объединяет большие наборы данных с режимом оптимизатора `FIRST_ROWS`, условие объединения является эффективным методом доступа к внутренней таблице.

**Примечание***:
Оптимизатором определяется количество строк, ожидаемых от объединения, а не размер базовых таблиц. Например, запрос может объединить две таблицы по миллиарду строк в каждой, но из-за фильтров оптимизатор ожидает наборы данных по 5 строк в каждом.
В общем, объединения с вложенными циклами лучше всего работают с небольшими таблицами, где условия объединения используют индексы.

В общем, объединения с вложенными циклами лучше всего работают с небольшими таблицами с индексами по условиям объединения. Если источник строки содержит только одну строку, как при поиске равенства по значению первичного ключа (например, `WHERE employee_id=101`), то объединение представляет собой простой поиск. Оптимизатор всегда пытается поместить наименьший источник строки первым, делая его исходной таблицей.

Различные факторы влияют на решение оптимизатора использовать вложенные циклы. Например, база данных может считывать несколько строк из внешнего источника строк в пакетном режиме. На основе количества извлеченных строк оптимизатор может выбрать либо вложенный цикл, либо хеш-соединение с внутренним набором данных.

Если путь доступа для внутреннего цикла не зависит от внешнего цикла, то результатом может быть декартово произведение: для каждой итерации внешнего цикла внутренний цикл создает один и тот же набор строк. Чтобы избежать этой проблемы, используйте другие методы объединения для соединения двух независимых источников данных.

#### 2.1.2 Как работают объединение вложенных циклов
Концептуально вложенные циклы эквивалентны двум вложенным `for` циклам.
Например, если запрос соединяет `employees` и `departments`, то вложенный цикл в псевдокоде может быть:
``` sql
FOR erow IN (select * from employees where X=Y) LOOP
	FOR drow IN (select * from departments where erow is matched) LOOP
		output values from erow and drow   
	END LOOP
END LOOP
```
Внутренний цикл выполняется для каждой строки внешнего цикла. Таблица **employees**  является "внешним" набором данных, поскольку она находится во внешнем цикле `for`. Внешнюю таблицу иногда называют _управляющей_ таблицей. Таблица `departments`  является "внутренним" набором данных, поскольку она находится во внутреннем цикле `for`.
Объединение вложенных циклов включает в себя следующие основные шаги:
1. 