## Предметная область
Курс на платформе Stepik состоит из нескольких модулей, каждый модуль включает несколько уроков, для каждого урока хранится информация о его положении в модуле. Каждый урок состоит из последовательности шагов. Каждый шаг имеет свой тип (это может быть текст, задание на SQL и пр.) и также порядковый номер в уроке.
Пользователи регистрируются на курсе, указывают свое имя. Когда пользователь проходит курс на платформе Stepik, все его действия оставляют "цифровой след": какие задания и когда он выполнил, сколько попыток сделал, правильно ли решил задание. Также хранятся все его комментарии. Если пользователь проходит курс и получает сертификат, то сохраняется дата его выдачи. Вся эта информация является первичной для **учебной аналитики.**
**Учебная аналитика** – это измерение, сбор, анализ и представление данных об обучающихся и их действиях на online платформе с целью понимания и оптимизации учебного процесса и той среды, где этот процесс происходит.
Для данного урока была создана база данных с полным описанием структуры курса. Учебная аналитика же включена в базу не в полном объеме, а только для некоторой группы пользователей из-за большого объема данных. Так, например, информация о решениях 17000 пользователей по нашему курсу за полгода его существования содержит 534500 записей. 
Пользователей для базы данных урока мы отобрали так:
-   отбросили всех, кто не выполнил ни одного задания (их оказалось 8800);
-   сгруппировали оставшихся пользователей в зависимости от количества решенных заданий, вот что получилось (считаем, что те, кто не отсылал задания больше месяца, покинули курс):
![[Stepic_IntTr_3.5.2.png]]
-   затем отобрали типичных представителей групп более или менее пропорционально численности каждой группы (имена пользователей, конечно, заменили);
-   поскольку пользователи отправляли от 1 до 1000 решений за время прохождения курса, в базу включили только попытки  шагов, относящихся к урокам 1.2, 2.2 и 2.4.
Получилось 64 пользователя и более 2000 их попыток.
> Группировка и выборка каждой группы обычно зависит от целей  исследования, например, если нужно понять когда и по какой причине пользователи покидают курс - то для начальных шагов нужно более "мелкое" деление.

**Логическая схема базы данных :**
![[Stepic_IntTr_3.5.1.png]]
**Пояснение**:
Время в этой таблице представлено в формате **Unix-время**, в котором хранится количество секунд, прошедших с 1 января 1970 года.
Для перевода к привычному типу `DATE` используется формула:
```sql
1970-01-01 + time_unix / 86400
```
В SQL для перевода удобно использовать функцию  
```sql
FROM_UNIXTIME(time_unix)
```

**Заметка**:
Регулярные выражения для поиска чего-то в **тексте** предпочтительнее, потому что функция INSTR предназначена для поиска какого-то символа/слова в тексте. Причем она как только найдет это, то сразу остановится и покажет вам, когда она нашла этот символ/слово. То есть если ищем символ "п" в выражении "привет, пока", то мы получил только первый символ в строке(вообще в программировании это обычно нулевой символ), то есть получим букву "п" из слова "привет", соответственно до слова "пока" и буквы "п" в этом слове не доберемся.
Так как функция INSTR дает(возвращает) число 0, если ничего не нашла, то её как бы можно использовать, делая условие, что она вернет значение больше 0 -> значит что-то нашла. Функция REGEXP возвращает булево значение(true/false), если что-то нашла, значит условие с ней проще, просто пишем where "переменная, в которой ищем" REGEXP (переменная, по которой ищем)
С этим разобрались, теперь осталось избавиться от тех случаев, когда у нас слово в слове(IN в INNER),и так далее, то есть сделать обработку. Тут опять же можно разными путями поступить, либо делать костыли(не самые удачные куски кода, которые подходят только под определенную задачу), то есть можно проверять уже не просто слово IN, а проверять, есть ли до него пробел, после него запятая или открывающая скобка(этих проверок хватает в этом задании). Чтобы это сделать, нам надо в условии проверять не просто keyword_name, а ещё и что до этого есть пробел и т.п. Делаем это с помощью функции CONCAT(' ', keyword_name). То есть мы уже смотрим не просто два символа "IN", а три символа " IN" (тут пробел и две буквы).  Также делаем с запятой и скобкой. 
Второй же вариант проверки, это специальные символы в регулярных выражениях, в нашем случае подойдет `\\b` 
Этот символ как раз и проверит на то, есть ли пробел, запятая, начало или конец строки и так далее, то есть этот символ обработает все проверки если его добавить. Ставить его нужно с двух сторон переменной. Чтобы его добавить в регулярное выражение, надо опять использовать CONCAT, только вместо пробелов " ", писать `\\b`.
[Документация по REGEXP на MySQL 8](https://dev.mysql.com/doc/refman/8.0/en/regexp.html)


## Выборка данных по нескольким условиям, оператор CASE
С помощью оператора **`CASE`** можно в зависимости от нескольких условий получить один из нескольких результатов.
Оператор `CASE` записывается в виде:
```sql
CASE  
     WHEN логическое_выражение_1 THEN выражение_1
     WHEN логическое_выражение_2 THEN выражение_2
     ...
     ELSE выражение_else   
END  
```
Раздел `ELSE` является необязательным.

Выполняется оператор `**CASE**` так:

-   вычисляется `**логическое_выражение_1**`, если оно истинно, то результатом оператора является `**выражение_1**`, если ложно - выполнение оператора продолжается;
-   вычисляется **`логическое_выражение_2`,** если оно истинно, то результатом оператора является `**выражение_2**`, если ложно - выполнение оператора продолжается;
-   если все логические выражения оказались ложными, то результат оператора - `**выражение_else**`

**`CASE`** можно использовать в  `**SELECT, UPDATE, DELETE, SET, WHERE, ORDER BY, HAVING**` - всюду, где можно использовать выражения.

**Пример**

Отнести каждого студента к группе,  в зависимости от пройденных заданий:

**Интервал**

**Группа**

от 0 до 10

I

от 11 до 15

II

от 16 до 27

III

больше 27

IV

Пройденными считаются задания с хотя бы одним верным ответом. В таблице `**step_student**` сохраняются все попытки пользователей, следовательно, могут быть пользователи, у которых на одно задание есть несколько верных попыток.

 _**Фрагмент логической схемы базы данных:**_

![](https://ucarecdn.com/e32cf2e7-200e-4ba9-9a7c-86244317d7fb/)

_**Шаг 1.**_ Выведем всех студентов и все шаги, которые они прошли с результатом "correct". Этот шаг обязателен, чтобы не учитывать  правильные решения несколько раз.

_Запрос:_

```sql
SELECT student_name, step_id
FROM 
    student 
    INNER JOIN step_student USING(student_id)
WHERE result = "correct"
GROUP BY student_name, step_id;
```

Результат:

```sql
Query result:
+--------------+---------+
| student_name | step_id |
+--------------+---------+
| student_52   | 10      |
| student_11   | 10      |
| student_19   | 10      |
| student_4    | 10      |
| student_5    | 10      |
| student_53   | 10      |
| student_39   | 10      |
| student_32   | 10      |
| student_61   | 10      |
| student_43   | 10      |
| student_13   | 10      |
| student_57   | 10      |
             ...
+--------------+---------+

Affected rows: 1126.
```

 _**Шаг 2.**_ Посчитаем, сколько шагов прошел каждый студент.

_Запрос:_

```sql
SELECT student_name, count(*) as rate
FROM 
    (
     SELECT student_name, step_id
     FROM 
         student 
         INNER JOIN step_student USING(student_id)
     WHERE result = "correct"
     GROUP BY student_name, step_id
    ) query_in
GROUP BY student_name
ORDER BY 2;
```

Результат:

```sql
+--------------+------+
| student_name | rate |
+--------------+------+
| student_29   | 8    |
| student_47   | 8    |
| student_16   | 9    |
| student_5    | 9    |
| student_63   | 9    |
| student_33   | 10   |
| student_17   | 10   |
| student_64   | 10   |
            ...
+--------------+------+
Affected rows: 64
```

**_Шаг 3_**. Отнести каждого студента к группе в зависимости от пройденных шагов.

 _Запрос:_

```sql
SELECT student_name, rate, 
    CASE
        WHEN rate <= 10 THEN "I"
        WHEN rate <= 15 THEN "II"
        WHEN rate <= 27 THEN "III"
        ELSE "IV"
    END AS Группа
FROM      
    (
     SELECT student_name, count(*) as rate
     FROM 
         (
          SELECT student_name, step_id
          FROM 
              student 
              INNER JOIN step_student USING(student_id)
          WHERE result = "correct"
          GROUP BY student_name, step_id
         ) query_in
     GROUP BY student_name 
     ORDER BY 2
    ) query_in_1;
```

_Результат:_

```sql
Query result:
+--------------+------+--------+
| student_name | rate | Группа |
+--------------+------+--------+
| student_29   | 8    | I      |
| student_47   | 8    | I      |
| student_16   | 9    | I      |
| student_5    | 9    | I      |
| student_63   | 9    | I      |
| student_33   | 10   | I      |
| student_17   | 10   | I      |
| student_64   | 10   | I      |
| student_58   | 10   | I      |
| student_38   | 10   | I      |
| student_12   | 11   | II     |
| student_10   | 11   | II     |
              ...
+--------------+------+--------+
Affected rows: 64
```

