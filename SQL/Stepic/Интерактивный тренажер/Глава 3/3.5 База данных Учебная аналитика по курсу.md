## Предметная область
Курс на платформе Stepik состоит из нескольких модулей, каждый модуль включает несколько уроков, для каждого урока хранится информация о его положении в модуле. Каждый урок состоит из последовательности шагов. Каждый шаг имеет свой тип (это может быть текст, задание на SQL и пр.) и также порядковый номер в уроке.
Пользователи регистрируются на курсе, указывают свое имя. Когда пользователь проходит курс на платформе Stepik, все его действия оставляют "цифровой след": какие задания и когда он выполнил, сколько попыток сделал, правильно ли решил задание. Также хранятся все его комментарии. Если пользователь проходит курс и получает сертификат, то сохраняется дата его выдачи. Вся эта информация является первичной для **учебной аналитики.**
**Учебная аналитика** – это измерение, сбор, анализ и представление данных об обучающихся и их действиях на online платформе с целью понимания и оптимизации учебного процесса и той среды, где этот процесс происходит.
Для данного урока была создана база данных с полным описанием структуры курса. Учебная аналитика же включена в базу не в полном объеме, а только для некоторой группы пользователей из-за большого объема данных. Так, например, информация о решениях 17000 пользователей по нашему курсу за полгода его существования содержит 534500 записей. 
Пользователей для базы данных урока мы отобрали так:
-   отбросили всех, кто не выполнил ни одного задания (их оказалось 8800);
-   сгруппировали оставшихся пользователей в зависимости от количества решенных заданий, вот что получилось (считаем, что те, кто не отсылал задания больше месяца, покинули курс):
![[Stepic_IntTr_3.5.2.png]]
-   затем отобрали типичных представителей групп более или менее пропорционально численности каждой группы (имена пользователей, конечно, заменили);
-   поскольку пользователи отправляли от 1 до 1000 решений за время прохождения курса, в базу включили только попытки  шагов, относящихся к урокам 1.2, 2.2 и 2.4.
Получилось 64 пользователя и более 2000 их попыток.
> Группировка и выборка каждой группы обычно зависит от целей  исследования, например, если нужно понять когда и по какой причине пользователи покидают курс - то для начальных шагов нужно более "мелкое" деление.

**Логическая схема базы данных :**
![[Stepic_IntTr_3.5.1.png]]
**Пояснение**:
Время в этой таблице представлено в формате **Unix-время**, в котором хранится количество секунд, прошедших с 1 января 1970 года.
Для перевода к привычному типу `DATE` используется формула:
```sql
1970-01-01 + time_unix / 86400
```
В SQL для перевода удобно использовать функцию  
```sql
FROM_UNIXTIME(time_unix)
```

**Заметка**:
Регулярные выражения для поиска чего-то в **тексте** предпочтительнее, потому что функция INSTR предназначена для поиска какого-то символа/слова в тексте. Причем она как только найдет это, то сразу остановится и покажет вам, когда она нашла этот символ/слово. То есть если ищем символ "п" в выражении "привет, пока", то мы получил только первый символ в строке(вообще в программировании это обычно нулевой символ), то есть получим букву "п" из слова "привет", соответственно до слова "пока" и буквы "п" в этом слове не доберемся.
Так как функция INSTR дает(возвращает) число 0, если ничего не нашла, то её как бы можно использовать, делая условие, что она вернет значение больше 0 -> значит что-то нашла. Функция REGEXP возвращает булево значение(true/false), если что-то нашла, значит условие с ней проще, просто пишем where "переменная, в которой ищем" REGEXP (переменная, по которой ищем)
С этим разобрались, теперь осталось избавиться от тех случаев, когда у нас слово в слове(IN в INNER),и так далее, то есть сделать обработку. Тут опять же можно разными путями поступить, либо делать костыли(не самые удачные куски кода, которые подходят только под определенную задачу), то есть можно проверять уже не просто слово IN, а проверять, есть ли до него пробел, после него запятая или открывающая скобка(этих проверок хватает в этом задании). Чтобы это сделать, нам надо в условии проверять не просто keyword_name, а ещё и что до этого есть пробел и т.п. Делаем это с помощью функции CONCAT(' ', keyword_name). То есть мы уже смотрим не просто два символа "IN", а три символа " IN" (тут пробел и две буквы).  Также делаем с запятой и скобкой. 
Второй же вариант проверки, это специальные символы в регулярных выражениях, в нашем случае подойдет `\\b` 
Этот символ как раз и проверит на то, есть ли пробел, запятая, начало или конец строки и так далее, то есть этот символ обработает все проверки если его добавить. Ставить его нужно с двух сторон переменной. Чтобы его добавить в регулярное выражение, надо опять использовать CONCAT, только вместо пробелов " ", писать `\\b`.
[Документация по REGEXP на MySQL 8](https://dev.mysql.com/doc/refman/8.0/en/regexp.html)


## Выборка данных по нескольким условиям, оператор CASE
С помощью оператора **`CASE`** можно в зависимости от нескольких условий получить один из нескольких результатов.
Оператор `CASE` записывается в виде:
```sql
CASE  
     WHEN логическое_выражение_1 THEN выражение_1
     WHEN логическое_выражение_2 THEN выражение_2
     ...
     ELSE выражение_else   
END  
```
Раздел `ELSE` является необязательным.
Выполняется оператор `CASE` так:
-   вычисляется **логическое_выражение_1**, если оно истинно, то результатом оператора является **выражение_1**, если ложно - выполнение оператора продолжается;
-   вычисляется **логическое_выражение_2**, если оно истинно, то результатом оператора является **выражение_2**, если ложно - выполнение оператора продолжается;
-   если все логические выражения оказались ложными, то результат оператора - **выражение_else**
`CASE` можно использовать в  `SELECT, UPDATE, DELETE, SET, WHERE, ORDER BY, HAVING` - всюду, где можно использовать выражения.
**Пример**
Отнести каждого студента к группе,  в зависимости от пройденных заданий:
![[Stepic_IntTr_3.5.4.png]]
Пройденными считаются задания с хотя бы одним верным ответом. В таблице **step_student** сохраняются все попытки пользователей, следовательно, могут быть пользователи, у которых на одно задание есть несколько верных попыток.
 _**Фрагмент логической схемы базы данных:**_
 ![[Stepic_IntTr_3.5.3.png]]
_**Шаг 1.**_ Выведем всех студентов и все шаги, которые они прошли с результатом "correct". Этот шаг обязателен, чтобы не учитывать правильные решения несколько раз.
_Запрос:_
```sql
SELECT student_name, step_id
FROM 
    student 
    INNER JOIN step_student USING(student_id)
WHERE result = "correct"
GROUP BY student_name, step_id;
```
Результат:
```sql
Query result:
+--------------+---------+
| student_name | step_id |
+--------------+---------+
| student_52   | 10      |
| student_11   | 10      |
| student_19   | 10      |
| student_4    | 10      |
| student_5    | 10      |
| student_53   | 10      |
| student_39   | 10      |
| student_32   | 10      |
| student_61   | 10      |
| student_43   | 10      |
| student_13   | 10      |
| student_57   | 10      |
             ...
+--------------+---------+

Affected rows: 1126.
```
_**Шаг 2.**_ Посчитаем, сколько шагов прошел каждый студент.
_Запрос:_
```sql
SELECT student_name, count(*) as rate
FROM 
    (
     SELECT student_name, step_id
     FROM 
         student 
         INNER JOIN step_student USING(student_id)
     WHERE result = "correct"
     GROUP BY student_name, step_id
    ) query_in
GROUP BY student_name
ORDER BY 2;
```
Результат:
```sql
+--------------+------+
| student_name | rate |
+--------------+------+
| student_29   | 8    |
| student_47   | 8    |
| student_16   | 9    |
| student_5    | 9    |
| student_63   | 9    |
| student_33   | 10   |
| student_17   | 10   |
| student_64   | 10   |
            ...
+--------------+------+
Affected rows: 64
```
**_Шаг 3_**. Отнести каждого студента к группе в зависимости от пройденных шагов.
_Запрос:_
```sql
SELECT student_name, rate, 
    CASE
        WHEN rate <= 10 THEN "I"
        WHEN rate <= 15 THEN "II"
        WHEN rate <= 27 THEN "III"
        ELSE "IV"
    END AS Группа
FROM      
    (
     SELECT student_name, count(*) as rate
     FROM 
         (
          SELECT student_name, step_id
          FROM 
              student 
              INNER JOIN step_student USING(student_id)
          WHERE result = "correct"
          GROUP BY student_name, step_id
         ) query_in
     GROUP BY student_name 
     ORDER BY 2
    ) query_in_1;
```
_Результат:_
```sql
Query result:
+--------------+------+--------+
| student_name | rate | Группа |
+--------------+------+--------+
| student_29   | 8    | I      |
| student_47   | 8    | I      |
| student_16   | 9    | I      |
| student_5    | 9    | I      |
| student_63   | 9    | I      |
| student_33   | 10   | I      |
| student_17   | 10   | I      |
| student_64   | 10   | I      |
| student_58   | 10   | I      |
| student_38   | 10   | I      |
| student_12   | 11   | II     |
| student_10   | 11   | II     |
              ...
+--------------+------+--------+
Affected rows: 64
```


## Табличные выражения, оператор WITH
Табличное выражение определяется с помощью оператора **`WITH`** и является частью запроса. Его синтаксис: 
```sql
WITH имя_выражения (имя_1, имя_2,...)
  AS
    (
     SELECT столбец_1, столбец_2,
     FROM 
       ... 
     )
SELECT ...
   FROM имя_выражения
   ...
```
В табличном выражении определяется запрос, результат которого нужно использовать в основной части запроса после `SELECT`. При этом основной запрос может обратиться к столбцам результата табличного выражения через имена, заданные в заголовке `WITH`. При этом количество имен должно совпадать с количеством результирующих столбцов табличного выражения.
В одном запросе может быть несколько табличных выражений. При этом в каждом табличном выражении можно использовать все предшествующие ему табличные выражения.
В табличном выражении необязательно давать имена столбцам результата. В этом случае в основном запросе можно использовать имена столбцов, указанных после `SELECT` в табличном выражении. При наличии одинаковых имен в нескольких табличных выражениях необходимо использовать полное имя столбца (имя табличного выражения, точка, имя столбца).
**Пример**
Для каждого шага вывести процент правильных решений. Информацию упорядочить по возрастанию процента верных решений. Столбцы результата назвать **Шаг** и **Успешность**, процент успешных решений округлить до целого.
**Важно.** Только для этого задания для одного из шагов установлено, что все ответы пользователей - неверные.
**Фрагмент логической схемы базы данных:**
![[Stepic_IntTr_3.5.5.png]]
**Шаг 1.** Создадим запрос, который для каждого шага вычисляет количество правильных ответов, данных пользователями.
_Запрос:_
```sql
SELECT step_name, count(*)
FROM 
    step 
    INNER JOIN step_student USING (step_id)
WHERE result = "correct"
GROUP BY step_name;
```
_Результат:_
```sql
+---------------------------------------------------------------+----------+
| step_name                                                     | count(*) |
+---------------------------------------------------------------+----------+
| Выборка всех данных из таблицы                                | 66       |
| Выборка отдельных столбцов                                    | 65       |
| Выборка отдельных столбцов и присвоение им новых имен         | 66       |
| Выборка данных с созданием вычисляемого столбца               | 64       |
| Выборка данных, вычисляемые столбцы, математические функции   | 66       |
                           ...
+---------------------------------------------------------------+----------+
Affected rows: 31
```
**Шаг 2.** Создадим запрос, который для каждого шага вычисляет количество неверных ответов, данных пользователями.
_Запрос:_
```sql
SELECT step_name, count(*)
FROM 
    step 
    INNER JOIN step_student USING (step_id)
WHERE result = "wrong"
GROUP BY step_name;
```
_Результат:_
```sql
+---------------------------------------------------------------+----------+
| step_name                                                     | count(*) |
+---------------------------------------------------------------+----------+
| Выборка всех данных из таблицы                                | 10       |
| Выборка отдельных столбцов                                    | 20       |
| Выборка отдельных столбцов и присвоение им новых имен         | 13       |
| Выборка данных с созданием вычисляемого столбца               | 23       |
                           ...
+---------------------------------------------------------------+----------+
Affected rows: 30
```
**Шаг 3.** Создадим запрос с табличными выражениями, который вычисляет процент верных решений. Запрос первого шага включим как табличное выражение с именем `get_count_correct`, запрос второго шага - как табличное выражение `get_count_wrong`.
_Запрос:_
```sql
WITH get_count_correct (st_n_c, count_correct) 
  AS (
      SELECT step_name, count(*)
      FROM 
          step 
          INNER JOIN step_student USING (step_id)
      WHERE result = "correct"
      GROUP BY step_name
   ),
  get_count_wrong (st_n_w, count_wrong) 
  AS (
    SELECT step_name, count(*)
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = "wrong"
    GROUP BY step_name
   )  
SELECT st_n_c AS Шаг, 
    ROUND(count_correct / (count_correct + count_wrong) * 100) AS Успешность
FROM  
    get_count_correct 
    INNER JOIN get_count_wrong ON st_n_c = st_n_w
```
_Результат:_
```sql
+--------------------------------------------------------------------------+------------+
| Шаг                                                                      | Успешность |
+--------------------------------------------------------------------------+------------
| Выборка данных, оператор LIKE                                            | 19         
| Вложенные запросы в операторах соединения                                | 32         
| Задание. Вывести самый популярный жанр                                   | 33         
| Запросы для нескольких таблиц с группировкой                             | 33         
                              ...
+--------------------------------------------------------------------------+------------+
Affected rows: 30
```
**Шаг 4.** Обратите внимание, что всего вопросов в таблице 32,  но запрос первого шага вывел общее количество вопросов - 31, а запрос второго шага - 30. Это значит, что на одно задание все пользователи дали неверный ответ, а на два -  все пользователи дали верный ответ. 
Следовательно, нужно вместо внутреннего соединения **`INNER JOIN`** применить полное внешнее соединение `FULL JOIN`. Это соединение в MySQL не поддерживается, его можно реализовать запросами с `LEFT` и `RIGHT JOIN`, соединенных оператором `UNION`:
```sql
SELECT ...
   FROM таблица_1 LEFT JOIN таблица_2 ON ...
...
UNION
SELECT ...
   FROM таблица_1 RIGHT JOIN таблица_2 ON ...
...
```
_Запрос шага 4_:
```sql
WITH get_count_correct (st_n_c, count_correct) 
  AS (
    SELECT step_name, count(*)
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = "correct"
    GROUP BY step_name
   ),
  get_count_wrong (st_n_w, count_wrong) 
  AS (
    SELECT step_name, count(*)
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = "wrong"
    GROUP BY step_name
   )  
SELECT st_n_c AS Шаг,
    ROUND(count_correct / (count_correct + count_wrong) * 100) AS Успешность
FROM  
    get_count_correct 
    LEFT JOIN get_count_wrong ON st_n_c = st_n_w
UNION
SELECT st_n_w AS Шаг,
    ROUND(count_correct / (count_correct + count_wrong) * 100) AS Успешность
FROM  
    get_count_correct 
    RIGHT JOIN get_count_wrong ON st_n_c = st_n_w
ORDER BY 2 ;
```
_Результат:_
```sql
+--------------------------------------------------------------------------+------------
| Шаг                                                                      | Успешность 
+--------------------------------------------------------------------------+------------
| Задание. Работа с архивной таблицей, оператор UNION, часть 1             | None       
| Задание. Работа с архивной таблицей, оператор UNION, часть 2             | None       
| Построение логической схемы базы данных                                  | None       
| Выборка данных, оператор LIKE                                            | 19         
| Вложенные запросы в операторах соединения                                | 32         
| Задание. Вывести самый популярный жанр                                   | 33         
| Запросы для нескольких таблиц с группировкой                             | 33   
                              ...
+--------------------------------------------------------------------------+------------+
Affected rows: 32
```
Процент успешных попыток для тех шагов, которые не имеют неверных ответов или не имеют верных - **Null**, а должно быть 100% и 0%  соответственно. Это произошло из-за того, что при внешнем соединении, вместо отсутствующего значения в результат подставляется **Null**.