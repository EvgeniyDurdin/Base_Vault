## Предметная область
В интернет-магазине продаются книги. Каждая книга имеет название, написана одним автором, относится к одному жанру, имеет определенную цену. В магазине в наличии есть несколько экземпляров каждой книги. 
Покупатель регистрируется на сайте интернет-магазина, задает свое имя и фамилию, электронную почту и город проживания. Он может сформировать один или несколько заказов, для каждого заказа написать какие-то пожелания. Каждый заказ включает одну или несколько книг, каждую книгу можно заказать в нескольких экземплярах. Затем заказ проходит ряд последовательных этапов (операций): оплачивается, упаковывается, передается курьеру или транспортной компании для транспортировки и, наконец, доставляется покупателю. Фиксируется дата каждой операции. Для каждого города известно среднее время доставки книг.
При этом в магазине ведется учет книг, при покупке их количество уменьшается, при поступлении товара увеличивается, при исчерпании количества – оформляется заказ и пр.


## Проектирование концептуальной модели базы данных

**Шаг 1.** Детально проанализировать предметную область и выделить те информационные объекты, которые будут храниться в базе данных (выделены жирным):
> В интернет-магазине продаются **книги**. Каждая книга имеет название, написана одним **автором**, относится к одному **жанру**, имеет определенную цену. В магазине в наличии есть несколько экземпляров каждой книги. 
> **Покупатель** регистрируется на сайте интернет-магазина, задает свое имя и фамилию,  электронную почту и **город** проживания (для упрощения считаем, что человек не может поменять свой город проживания). Он может сформировать один или несколько **заказов**,  для каждого заказа написать какие-то пожелания. Каждый заказ включает одну или несколько книг, каждую книгу можно заказать в нескольких экземплярах. Затем заказ проходит ряд последовательных **этапов** (операций): оплачивается, упаковывается, передается курьеру или транспортной компании для транспортировки и, наконец, доставляется покупателю. Фиксируется дата каждой операции. Для каждого города известно среднее время доставки книг.
> При этом в магазине ведется учет книг, при покупке их количество уменьшается, при поступлении товара увеличивается, при исчерпании количества – оформляется заказ и пр.

**Шаг 2.** Для каждого выделенного информационного объекта указать его характеристики, для этого:
а) сначала выделить их в описании предметной области (выделено курсивом): 
> В интернет-магазине продаются **книги**. Каждая книга имеет _название_, написана одним **автором**, относится к одному **жанру**, имеет определенную _цену_. В магазине в наличии есть _несколько экземпляров_ каждой книги. 
> **Покупатель** регистрируется на сайте интернет-магазина, задает свое _имя и фамилию_,  _электронную почту_ и **город** проживания. Он может сформировать один или несколько **заказов**, для каждого заказа написать какие-то _пожелания_. Каждый заказ включает _одну или несколько книг_, каждую книгу можно заказать _в нескольких экземплярах_. Затем заказ проходит ряд последовательных **этапов**(операций): оплачивается, упаковывается, передается курьеру или транспортной компании для транспортировки и, наконец, доставляется покупателю. Фиксируется _дата каждой операции_. Для каждого города известно _среднее время доставки книг_.
> При этом в магазине ведется учет книг, при покупке их количество уменьшается, при поступлении товара увеличивается, при исчерпании количества – оформляется заказ и пр.

б) затем связать их с информационным объектом: 
-   **Книга** – название, количество, цена;
-   **Автор** – фамилия и инициалы;
-   **Жанр** – название;
-   **Покупатель (клиент)** – фамилия и имя, электронная почта;
-   **Город** – название, среднее время доставки;
-   **Заказ** – код заказа, пожелания;
-   **Этап** – название этапов.
в) перечислить характеристики, которые остались не привязанными к информационным объектам (к ним необходимо вернуться при реализации связей между таблицами): 
-   книги в заказе;
-   количество книг в заказе;
-   дата каждой операции.
**Шаг 3.** Нарисовать схему, на которой изобразить информационные объекты в виде прямоугольников:
![[Stepic_IntTr_2.4.1.jpg]]
**Шаг 4.** Установить связи между информационными объектами. Связь «один ко многим» обозначить в виде →, «многие ко многим» –  ↔.
-   Каждая **книга** написана одним **автором**, каждый **автор** написал несколько **книг**, следовательно между этими таблицами связь «один ко многим»:
![[Stepic_IntTr_2.4.2.jpg]]
-   Каждая **книга** может включаться в несколько **заказов**, один **заказ** может содержать несколько **книг**, между этими таблицами связь «многие ко многим»:
![[Stepic_IntTr_2.4.3.jpg]]
-   Каждый **клиент** может сформировать несколько **заказов**, каждый **заказ** формируется только одним **клиентом**:
![[Stepic_IntTr_2.4.4.jpg]]


## Построение логической схемы базы данных
На предыдущем шаге получена концептуальная модель базы данных:
![[Stepic_IntTr_2.4.5.jpg]]
На основе этой модели создается логическая модель, в которой информационные объекты описываются в виде реляционных таблиц.
Для каждой пары таблиц необходимо выполнить следующие шаги:
**Шаг 1**. Выбрать пару таблиц из схемы, например:
![[Stepic_IntTr_2.4.9.jpg]]
**Шаг 2**. Разработать структуру таблиц для каждого информационного объекта. Таблица в качестве столбцов должна включать все характеристики информационного объекта, полученные на этапе концептуального проектирования, кроме тех, которые соответствуют названиям других информационных объектов. Они будут включены в таблицы при создании связей.  В нашем случае это:
![[Stepic_IntTr_2.4.6.jpg]]
**Шаг 3**. Реализовать связь между таблицами, в нашем случае это связь «один ко многим»:
![[Stepic_IntTr_2.4.8.jpg]]
**Шаг 4.** Вернуться к описанию концептуальной модели и проверить, нужно ли включить какие-то характеристики, непривязанные к информационным объектам? В нашем случае ничего добавлять не надо. Чаще всего характеристики добавляются при реализации связи «многие ко многим».
Продолжим построение логической схемы:
**Шаг 1.** Выберем следующую пару таблиц:
![[Stepic_IntTr_2.4.7.jpg]]
**Шаг 2**. Структура таблиц каждого информационного объекта (сохраняем уже полученные ранее структуры таблиц):
![[Stepic_IntTr_2.4.10.jpg]]
**Шаг 3**. Реализуем связь «многие ко многим»:
![[Stepic_IntTr_2.4.11.jpg]]
**Шаг 4**. В описании предметной области указывается, что нужно хранить количество книг, которые включены в заказ. Добавим эту характеристику в таблицу-связку `**buy_book**`:
![[Stepic_IntTr_2.4.12.jpg]]


## ​Логическая модель базы данных
![[Stepic_IntTr_2.4.13.jpg]]
​Логическая модель базы данных служит основой для физической модели, в которой определяются характеристики каждого столбца (тип и другие опции). После создания структуры, таблицы наполняются информацией.


## Запросы на основе трех и более связанных таблиц
**Пример**
Вывести фамилии всех клиентов, которые заказали книгу Булгакова «Мастер и Маргарита».
_Запрос:_
Этот запрос строится на основе нескольких таблиц, для удобства нужно определить фрагмент логической схемы базы данных, на основе которой строится запрос. В нашем случае выбираются название книги из таблицы **book** и фамилия клиента из таблицы **client**. Эти таблицы между собой непосредственно не связаны, поэтому нужно добавить «связующие» таблицы  **buy** и **buy_book**:
Для соединения этих таблиц используется `INNER JOIN`. Для удобства рекомендуется связи описывать последовательно: **client** → **buy** → **buy_book** → **book**.  А для соединения использовать пару **первичный ключ** и **внешний ключ** соответствующих таблиц. Например, соединение таблиц **client** и **buy** осуществляется по условию `client.client_id = buy.client_id`.
Чтобы не усложнять схему, будем считать, что нам известен **id** Булгакова (это 1)
```sql
SELECT DISTINCT name_client
FROM 
    client 
    INNER JOIN buy ON client.client_id = buy.client_id
    INNER JOIN buy_book ON buy_book.buy_id = buy.buy_id
    INNER JOIN book ON buy_book.book_id=book.book_id
WHERE title ='Мастер и Маргарита' and author_id = 1;                    
```
В запросе отбираются уникальные клиенты (`DISTINCT`) так как один и тот же клиент мог заказать одну и ту же книгу несколько раз.
_Результат:_
```sql
+---------------+
| name_client   |
+---------------+
| Баранов Павел |
| Абрамова Катя |
+---------------+
```


## Оператор UNION
Оператор `UNION` используется для объединения двух и более SQL запросов, его синтаксис:
```sql
SELECT столбец_1_1, столбец_1_2, ...
FROM 
  ...
UNION
SELECT столбец_2_1, столбец_2_2, ...
FROM 
  ...
```
или
```sql
SELECT столбец_1_1, столбец_1_2, ...
FROM 
  ...
UNION ALL
SELECT столбец_2_1, столбец_2_2, ...
FROM 
  ...
```
Важно отметить, что каждый из `SELECT` должен иметь в своем запросе одинаковое количество столбцов и  совместимые типы возвращаемых данных. Каждый запрос может включать разделы `WHERE`, `GROUP BY` и пр.
В результате выполнения этой конструкции будет выведена таблица, имена столбцов которой соответствуют именам столбцов в первом запросе. А в таблице результата сначала отображаются записи-результаты первого запроса, а затем второго. Если указано ключевое слово `ALL`, то в результат включаются все записи запросов, в противном случае - различные.
**Пример**
Вывести всех клиентов, которые делали заказы или в этом, или в предыдущем году.
На этом примере рассмотрим разницу между `UNION` и `UNION ALL`.
С `UNION` клиенты будут выведены без повторений:
```sql
SELECT name_client
FROM 
    buy_archive
    INNER JOIN client USING(client_id)
UNION
SELECT name_client
FROM 
    buy 
    INNER JOIN client USING(client_id)
+-----------------+
| name_client     |
+-----------------+
| Баранов Павел   |
| Абрамова Катя   |
| Яковлева Галина |
| Семенонов Иван  |
+-----------------+
Affected rows: 4
```

C `UNION ALL` будут выведены клиенты с повторением (для тех, кто заказывал книги в обоих годах, а также несколько раз в одном году)
```sql
SELECT name_client
FROM 
    buy_archive
    INNER JOIN client USING(client_id)
UNION ALL
SELECT name_client
FROM 
    buy 
    INNER JOIN client USING(client_id)
+-----------------+
| name_client     |
+-----------------+
| Баранов Павел   |
| Баранов Павел   |
| Абрамова Катя   |
| Абрамова Катя   |
| Абрамова Катя   |
| Яковлева Галина |
| Яковлева Галина |
| Баранов Павел   |
| Абрамова Катя   |
| Абрамова Катя   |
| Баранов Павел   |
| Баранов Павел   |
| Абрамова Катя   |
| Семенонов Иван  |
+-----------------+
Affected rows: 14
```
**Пример**
Вывести информацию об оплаченных заказах за предыдущий и текущий год, информацию отсортировать по  **client_id**.
_Запрос:_
```sql
SELECT buy_id, client_id, book_id, date_payment, amount, price
FROM 
    buy_archive
UNION ALL
SELECT buy.buy_id, client_id, book_id, date_step_end, buy_book.amount, price
FROM 
    book 
    INNER JOIN buy_book USING(book_id)
    INNER JOIN buy USING(buy_id) 
    INNER JOIN buy_step USING(buy_id)
    INNER JOIN step USING(step_id)                  
WHERE  date_step_end IS NOT Null and name_step = "Оплата"  
```
_Результат:_
```sql
+--------+-----------+---------+--------------+--------+--------+
| buy_id | client_id | book_id | date_payment | amount | price  |
+--------+-----------+---------+--------------+--------+--------+
| 2      | 1         | 1       | 2019-02-21   | 2      | 670.60 |
| 2      | 1         | 3       | 2019-02-21   | 1      | 450.90 |
| 1      | 2         | 2       | 2019-02-10   | 2      | 520.30 |
| 1      | 2         | 4       | 2019-02-10   | 3      | 780.90 |
| 1      | 2         | 3       | 2019-02-10   | 1      | 450.90 |
| 3      | 4         | 4       | 2019-03-05   | 4      | 780.90 |
| 3      | 4         | 5       | 2019-03-05   | 2      | 480.90 |
| 4      | 1         | 6       | 2019-03-12   | 1      | 650.00 |
| 5      | 2         | 1       | 2019-03-18   | 2      | 670.60 |
| 5      | 2         | 4       | 2019-03-18   | 1      | 780.90 |
| 1      | 1         | 3       | 2020-02-20   | 1      | 460.00 |
| 1      | 1         | 7       | 2020-02-20   | 2      | 570.20 |
| 1      | 1         | 1       | 2020-02-20   | 1      | 670.99 |
| 2      | 3         | 8       | 2020-02-28   | 2      | 518.99 |
| 3      | 2         | 1       | 2020-03-05   | 1      | 670.99 |
| 3      | 2         | 2       | 2020-03-05   | 1      | 540.50 |
| 3      | 2         | 3       | 2020-03-05   | 2      | 460.00 |
+--------+-----------+---------+--------------+--------+--------+
```
В результат включены сначала записи архивной таблицы, а затем информация об оплаченных заказах  текущего года. Для того, чтобы изменить порядок следования записей в объединенном запросе, можно использовать **сортировку** по всем объединенным записям. В этом случае ключевые слова `ORDER BY` указываются после последнего запроса: 
```sql
SELECT buy_id, client_id, book_id, date_payment, amount, price
FROM 
    buy_archive
UNION ALL
SELECT buy.buy_id, client_id, book_id, date_step_end, buy_book.amount, price
FROM 
    book 
    INNER JOIN buy_book USING(book_id)
    INNER JOIN buy USING(buy_id) 
    INNER JOIN buy_step USING(buy_id)
    INNER JOIN step USING(step_id)                  
WHERE  date_step_end IS NOT Null and name_step = "Оплата"
ORDER BY client_id
```
_Результат:_
```sql
+--------+-----------+---------+--------------+--------+--------+
| buy_id | client_id | book_id | date_payment | amount | price  |
+--------+-----------+---------+--------------+--------+--------+
| 2      | 1         | 3       | 2019-02-21   | 1      | 450.90 |
| 2      | 1         | 1       | 2019-02-21   | 2      | 670.60 |
| 1      | 1         | 3       | 2020-02-20   | 1      | 460.00 |
| 1      | 1         | 7       | 2020-02-20   | 2      | 570.20 |
| 4      | 1         | 6       | 2019-03-12   | 1      | 650.00 |
| 1      | 1         | 1       | 2020-02-20   | 1      | 670.99 |
| 3      | 2         | 1       | 2020-03-05   | 1      | 670.99 |
| 3      | 2         | 2       | 2020-03-05   | 1      | 540.50 |
| 3      | 2         | 3       | 2020-03-05   | 2      | 460.00 |
| 5      | 2         | 4       | 2019-03-18   | 1      | 780.90 |
| 5      | 2         | 1       | 2019-03-18   | 2      | 670.60 |
| 1      | 2         | 3       | 2019-02-10   | 1      | 450.90 |
| 1      | 2         | 4       | 2019-02-10   | 3      | 780.90 |
| 1      | 2         | 2       | 2019-02-10   | 2      | 520.30 |
| 2      | 3         | 8       | 2020-02-28   | 2      | 518.99 |
| 3      | 4         | 5       | 2019-03-05   | 2      | 480.90 |
| 3      | 4         | 4       | 2019-03-05   | 4      | 780.90 |
+--------+-----------+---------+--------------+--------+--------+
```


