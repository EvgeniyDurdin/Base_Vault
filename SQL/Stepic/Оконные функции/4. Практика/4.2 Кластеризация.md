### 4.2.1 Кластеризация
При анализе данных бывает удобно разбить набор данных на группы близких значений. Частный случай такой задачи — поиск _островов_ в данных (islands).
Остров — это последовательность идущих подряд значений. Например, есть числа:
```sql
select * from numbers;

┌─────┐
│ num │
├─────┤
│ 51  │
│ 52  │
│ 53  │
│ 55  │
│ 56  │
│ 59  │
└─────┘
```
Они идут не подряд, а с промежутками, и образуют три острова:
- (51, 52, 53)
- (55, 56)
- (59)
Хотелось бы автоматически найти все острова и количество значений в каждом. Это несложная задача для императивных языков программирования вроде Python, но нетривиальная для SQL. Однако, решаемая — с помощью оконных функций.

### 4.2.2 Идентифицируем острова
Для начала, пронумеруем записи по возрастанию значений:
```sql
select
  num,
  row_number() over w as rownum
from numbers
window w as (order by num);

┌─────┬────────┐
│ num │ rownum │
├─────┼────────┤
│ 51  │ 1      │
│ 52  │ 2      │
│ 53  │ 3      │
│ 55  │ 4      │
│ 56  │ 5      │
│ 59  │ 6      │
└─────┴────────┘
```
Сам по себе номер строки не слишком интересен, но у него есть полезное свойство — пока значения `num` идут подряд, разность `num-rownum` постоянна:
```sql
select
  num,
  row_number() over w as rownum,
  num - row_number() over w as group_id
from numbers
window w as (order by num);

┌─────┬────────┬──────────┐
│ num │ rownum │ group_id │
├─────┼────────┼──────────┤
│ 51  │ 1      │ 50       │
│ 52  │ 2      │ 50       │
│ 53  │ 3      │ 50       │
│ 55  │ 4      │ 51       │
│ 56  │ 5      │ 51       │
│ 59  │ 6      │ 53       │
└─────┴────────┴──────────┘
```
Раз `num-rownum` не меняется для идущих подряд значений `num` — эту разность можно считать идентификатором острова (`group_id`). Осталось только сгруппировать по нему, чтобы получить границы островов и количество записей в каждом:
```sql
with ngroups as (
  select
    num,
    num - row_number() over w as group_id
  from numbers
  window w as (order by num)
)
select
  min(num) as n_start,
  max(num) as n_end,
  count(*) as n_count
from ngroups
group by group_id;

┌─────────┬───────┬─────────┐
│ n_start │ n_end │ n_count │
├─────────┼───────┼─────────┤
│ 51      │ 53    │ 3       │
│ 55      │ 56    │ 2       │
│ 59      │ 59    │ 1       │
└─────────┴───────┴─────────┘
```
Получились те же самые группы, что мы раньше идентифицировали вручную:
- `51-53` (3 значения)
- `55-56` (2 значения)
- `59` (1 значение)

### 4.2.3 Острова на датах
Представьте себе обучающую платформу, на которой люди выполняют задания и получают за это баллы (что-то напоминает, да? ツ). В базе данных такой платформы может быть таблица `activity`, которая хранит баллы, набранные пользователями в конкретные дни:
```sql
┌────────────┬─────────┬────────┐
│   adate    │ user_id │ points │
├────────────┼─────────┼────────┤
│ 2020-02-01 │ 51      │ 1      │
│ 2020-02-02 │ 11      │ 1      │
│ 2020-02-02 │ 51      │ 3      │
│ 2020-02-05 │ 21      │ 6      │
│ ...        │ ...     │ ...    │
│ 2020-02-25 │ 51      │ 1      │
└────────────┴─────────┴────────┘
```
[activity.sql](https://gist.github.com/nalgeon/72fb11d6382074248d7da0f1505365b6)
Допустим, нас интересуют острова по датам для пользователя `51` — то есть периоды времени, когда он занимался каждый день без перерыва.
Таблица игрушечная, поэтому для начала посчитаем вручную:
```sql
select adate, points
from activity
where user_id = 51
order by adate;

┌────────────┬────────┐
│   adate    │ points │
├────────────┼────────┤
│ 2020-02-01 │ 1      │
│ 2020-02-02 │ 3      │
│ 2020-02-03 │ 2      │
│ 2020-02-04 │ 6      │
│ 2020-02-05 │ 3      │
│ 2020-02-08 │ 1      │
│ 2020-02-09 │ 1      │
│ 2020-02-10 │ 1      │
│ 2020-02-20 │ 9      │
│ 2020-02-21 │ 15     │
│ 2020-02-22 │ 7      │
│ 2020-02-25 │ 1      │
└────────────┴────────┘
```
Здесь четыре острова:
- 01.02 — 05.02 (5 дней),
- 08.02 — 10.02 (3 дня),
- 20.02 — 22.02 (3 дня),
- 25.02 (1 день).
Теперь попробуем найти острова с помощью SQL. Вспомним прием, который помог нам найти острова на числах:
```sql
select
  num,
  num - dense_rank() over w as group_id
from numbers
window w as (order by num);

┌─────┬──────────┐
│ num │ group_id │
├─────┼──────────┤
│ 51  │ 50       │
│ 52  │ 50       │
│ 52  │ 50       │
│ 53  │ 50       │
│ 55  │ 51       │
│ 56  │ 51       │
│ 59  │ 53       │
└─────┴──────────┘
```
Чтобы применить тот же прием к столбцу `adate`, нам нужно следующее:
- преобразовать даты в целые числа;
- причем так, чтобы соседние даты отличались на 1.
Можно поставить каждой дате в соответствие количество дней от некоторой общей точки отсчета — это как раз и будет интересующим нас числом.

**Как преобразовать дату в количество дней**
К сожалению, каждая СУБД реализует работу с датами по-своему, поэтому универсального решения не существует. В MySQL, например, есть функция `to_days()`:
```sql
select
  adate,
  to_days(adate) as day_id
from activity
where user_id = 51;
```
В PostgreSQL придется использовать `extract()`:
```sql
select
  adate,
  extract(epoch from adate)/86400 as day_id
from activity
where user_id = 51;
```
А в SQLite — `unixepoch()`:
```sql
select
  adate,
  unixepoch(adate)/86400 as day_id
from activity
where user_id = 51;
```

Преобразовав дату в число, мы можем использовать `dense_rank()`:
```sql
select
  adate,
  unixepoch(adate)/86400 - dense_rank() over w as group_id
from activity
where user_id = 51
window w as (order by adate);

┌────────────┬──────────┐
│   adate    │ group_id │
├────────────┼──────────┤
│ 2020-02-01 │ 18292    │
│ 2020-02-02 │ 18292    │
│ 2020-02-03 │ 18292    │
│ 2020-02-04 │ 18292    │
│ 2020-02-05 │ 18292    │
│ 2020-02-08 │ 18294    │
│ 2020-02-09 │ 18294    │
│ 2020-02-10 │ 18294    │
│ 2020-02-20 │ 18303    │
│ 2020-02-21 │ 18303    │
│ 2020-02-22 │ 18303    │
│ 2020-02-25 │ 18305    │
└────────────┴──────────┘
```
Осталось только сгруппировать по `group_id`:
```sql
with agroups as (
  select
    adate,
    unixepoch(adate)/86400 - dense_rank() over w as group_id
  from activity
  where user_id = 51
  window w as (order by adate)
)
select
  min(adate) as day_start,
  max(adate) as day_end,
  count(*) as day_count
from agroups
group by group_id;

┌────────────┬────────────┬───────────┐
│ day_start  │  day_end   │ day_count │
├────────────┼────────────┼───────────┤
│ 2020-02-01 │ 2020-02-05 │ 5         │
│ 2020-02-08 │ 2020-02-10 │ 3         │
│ 2020-02-20 │ 2020-02-22 │ 3         │
│ 2020-02-25 │ 2020-02-25 │ 1         │
└────────────┴────────────┴───────────┘
```
Вот и искомые острова!

### 4.2.4 Кластеры значений
Мы начали урок с того, что при анализе данных бывает удобно разбить набор данных на группы близких значений. Но «близкие» не всегда означает «идущие подряд». Иногда мы готовы включить в одну группу значения с небольшими промежутками.
Например, есть числа:
```sql
select * from numbers;

┌─────┐
│ num │
├─────┤
│ 51  │
│ 52  │
│ 53  │
│ 55  │
│ 56  │
│ 59  │
│ 61  │
│ 72  │
└─────┘
```
Договоримся, что соседние значения входят в одну и ту же группу, если отличаются на 1 или 2. Тогда получится три группы (или _кластера_):
- (51, 52, 53, 55, 56)
- (59, 61)
- (72)
Попробуем найти кластеры с помощью SQL. Сразу скажу, что подход с ранжированием строк здесь не сработает, поскольку мы разрешили промежутки между соседними значениями. Поэтому поступим иначе.
Для начала, посчитаем расстояние между соседями с помощью функции `lag()`:
```sql
select
  num,
  num - lag(num) over w as n_lag
from numbers
window w as (order by num);

┌─────┬───────┐
│ num │ n_lag │
├─────┼───────┤
│ 51  │       │
│ 52  │ 1     │
│ 53  │ 1     │
│ 55  │ 2     │
│ 56  │ 1     │
│ 59  │ 3     │
│ 61  │ 2     │
│ 72  │ 11    │
└─────┴───────┘
```
Теперь идентифицируем границы между кластерами по такому правилу:
> Если расстояние между соседними значениями больше 2, то это разные кластеры.
```sql
-- расстояния между соседями
with nlags as (
  select
    num,
    num - lag(num) over w as n_lag
  from numbers
  window w as (order by num)
)
-- границы кластеров
select
  num,
  n_lag,
  case when n_lag > 2 then 1 else 0 end as is_boundary
from nlags;

┌─────┬───────┬─────────────┐
│ num │ n_lag │ is_boundary │
├─────┼───────┼─────────────┤
│ 51  │       │ 0           │
│ 52  │ 1     │ 0           │
│ 53  │ 1     │ 0           │
│ 55  │ 2     │ 0           │
│ 56  │ 1     │ 0           │
│ 59  │ 3     │ 1           │
│ 61  │ 2     │ 0           │
│ 72  │ 11    │ 1           │
└─────┴───────┴─────────────┘
```
Границы уже явно видны. Теперь пронумеруем кластеры по порядку:
```sql
-- расстояния между соседями
with nlags as (
  select
    num,
    num - lag(num) over w as n_lag
  from numbers
  window w as (order by num)
)
-- границы кластеров
select
  num,
  sum(case when n_lag > 2 then 1 else 0 end) over w as group_id
from nlags
window w as (order by num);
```
Здесь идентификатор кластера считается как количество предшествующих ему границ (то есть порядковый номер кластера, считая с 0):
```sql
┌─────┬──────────┐
│ num │ group_id │
├─────┼──────────┤
│ 51  │ 0        │
│ 52  │ 0        │
│ 53  │ 0        │
│ 55  │ 0        │
│ 56  │ 0        │
│ 59  │ 1        │
│ 61  │ 1        │
│ 72  │ 2        │
└─────┴──────────┘
```
Наконец, агрегируем по идентификатору кластера:
```sql
-- расстояния между соседями
with nlags as (
  select
    num,
    num - lag(num) over w as n_lag
  from numbers
  window w as (order by num)
),
-- границы кластеров
ngroups as (
  select
    num,
    sum(case when n_lag > 2 then 1 else 0 end) over w as group_id
  from nlags
  window w as (order by num)
)
-- сами кластеры
select
  min(num) as n_start,
  max(num) as n_end,
  count(*) as n_count
from ngroups
group by group_id;

┌─────────┬───────┬─────────┐
│ n_start │ n_end │ n_count │
├─────────┼───────┼─────────┤
│ 51      │ 56    │ 5       │
│ 59      │ 61    │ 2       │
│ 72      │ 72    │ 1       │
└─────────┴───────┴─────────┘
```
То, что нужно!
Вот универсальный алгоритм поиска кластеров на SQL:
1. Посчитать расстояние `L` между соседними значениями через `lag()`.
2. Идентифицировать границы по условию `sum(case when L > N then 1 else 0 end)`, где `N` — максимально допустимое расстояние между соседними значениями кластера.
3. Агрегировать кластеры по идентификатору.
Острова можно было считать по этому же алгоритму. Но там мы «срезали путь» через ранжирование, потому что точно знали, что соседние значения отличаются ровно на 1.

### 4.2.5 Кластеры на датах
Вернемся к таблице `activity`, которая хранит баллы, набранные пользователями в конкретные дни:
```sql
┌────────────┬─────────┬────────┐
│   adate    │ user_id │ points │
├────────────┼─────────┼────────┤
│ 2020-02-01 │ 51      │ 1      │
│ 2020-02-02 │ 11      │ 1      │
│ 2020-02-02 │ 51      │ 3      │
│ 2020-02-05 │ 21      │ 6      │
│ ...        │ ...     │ ...    │
│ 2020-02-25 │ 51      │ 1      │
└────────────┴─────────┴────────┘
```
Договоримся, что пропуск одного дня не прерывает серию. Как тогда будут выглядеть кластеры?
Рассмотрим пользователя `21`:
```sql
select adate, points
from activity
where user_id = 21;

┌────────────┬────────┐
│   adate    │ points │
├────────────┼────────┤
│ 2020-02-05 │ 6      │
│ 2020-02-07 │ 2      │
│ 2020-02-09 │ 4      │
│ 2020-02-11 │ 6      │
│ 2020-02-13 │ 3      │
│ 2020-02-15 │ 5      │
│ 2020-02-20 │ 5      │
│ 2020-02-23 │ 3      │
│ 2020-02-24 │ 1      │
└────────────┴────────┘
```
Вот его серии:
- 05.02 — 15.02 (6 дней),
- 20.02 (1 день),
- 23.02 — 24.02 (2 дня).
Посчитаем кластеры с помощью SQL. Вспомним универсальный алгоритм:
1. Посчитать расстояние `L` между соседними значениями через `lag()`.
2. Идентифицировать границы по условию `sum(case when L > N then 1 else 0 end)`, где `N` — максимально допустимое расстояние между соседними значениями кластера (в нашем случае N = 2).
3. Агрегировать кластеры по идентификатору.
**Шаг 1**. Переводим даты в числа и считаем расстояние между соседями:
```sql
select
  adate, 
  unixepoch(adate)/86400 - lag(unixepoch(adate)/86400) over w as day_lag
from activity
where user_id = 21
window w as (order by adate);

┌────────────┬─────────┐
│   adate    │ day_lag │
├────────────┼─────────┤
│ 2020-02-05 │         │
│ 2020-02-07 │ 2       │
│ 2020-02-09 │ 2       │
│ 2020-02-11 │ 2       │
│ 2020-02-13 │ 2       │
│ 2020-02-15 │ 2       │
│ 2020-02-20 │ 5       │
│ 2020-02-23 │ 3       │
│ 2020-02-24 │ 1       │
└────────────┴─────────┘
```
**Шаг 2**. Идентифицируем границы кластеров:
```sql
-- расстояния между соседями
with adays as (
  select
    adate, 
    unixepoch(adate)/86400 - lag(unixepoch(adate)/86400) over w as day_lag
  from activity
  where user_id = 21
  window w as (order by adate)
)
-- границы кластеров
select
  adate, day_lag,
  sum(case when day_lag > 2 then 1 else 0 end) over w as group_id
from adays
window w as (order by adate);

┌────────────┬─────────┬──────────┐
│   adate    │ day_lag │ group_id │
├────────────┼─────────┼──────────┤
│ 2020-02-05 │         │ 0        │
│ 2020-02-07 │ 2       │ 0        │
│ 2020-02-09 │ 2       │ 0        │
│ 2020-02-11 │ 2       │ 0        │
│ 2020-02-13 │ 2       │ 0        │
│ 2020-02-15 │ 2       │ 0        │
│ 2020-02-20 │ 5       │ 1        │
│ 2020-02-23 │ 3       │ 2        │
│ 2020-02-24 │ 1       │ 2        │
└────────────┴─────────┴──────────┘
```
**Шаг 3**. Агрегируем кластеры по идентификатору:
```sql
-- расстояния между соседями
with adays as (
  select
    adate, 
    unixepoch(adate)/86400 - lag(unixepoch(adate)/86400) over w as day_lag
  from activity
  where user_id = 21
  window w as (order by adate)
),
-- границы кластеров
agroups as (
  select
    adate, day_lag,
    sum(case when day_lag > 2 then 1 else 0 end) over w as group_id
  from adays
  window w as (order by adate)
)
-- сами кластеры
select 
  min(adate) as day_start,
  max(adate) as day_end,
  count(*) as day_count
from agroups
group by group_id;

┌────────────┬────────────┬───────────┐
│ day_start  │  day_end   │ day_count │
├────────────┼────────────┼───────────┤
│ 2020-02-05 │ 2020-02-15 │ 6         │
│ 2020-02-20 │ 2020-02-20 │ 1         │
│ 2020-02-23 │ 2020-02-24 │ 2         │
└────────────┴────────────┴───────────┘
```
Вот и искомые кластеры!