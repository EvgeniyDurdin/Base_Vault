### 4.1.1 Определение предметной области
Оконные функции часто используют в продуктовой и финансовой аналитике. Поэтому на этом уроке порешаем задачки, связанные с продажами и тарифами.
Предположим, у вас есть облачный сервис. Вы продаете подписки на тарифные планы silver, gold и platinum. Таблица `sales` содержит агрегированные данные о продажах по каждому тарифу за месяц (за 2019 и 2020 годы):
```sql
select * from sales limit 10;

┌──────┬───────┬─────────┬──────────┬───────┬──────────┬─────────┐
│ year │ month │ quarter │   plan   │ price │ quantity │ revenue │
├──────┼───────┼─────────┼──────────┼───────┼──────────┼─────────┤
│ 2019 │ 1     │ 1       │ silver   │ 60    │ 200      │ 12000   │
│ 2019 │ 1     │ 1       │ gold     │ 240   │ 50       │ 12000   │
│ 2019 │ 1     │ 1       │ platinum │ 600   │ 10       │ 6000    │
│ 2019 │ 2     │ 1       │ silver   │ 60    │ 660      │ 39600   │
│ 2019 │ 2     │ 1       │ gold     │ 240   │ 60       │ 14400   │
│ 2019 │ 2     │ 1       │ platinum │ 600   │ 15       │ 9000    │
│ 2019 │ 3     │ 1       │ silver   │ 60    │ 400      │ 24000   │
│ 2019 │ 3     │ 1       │ gold     │ 240   │ 96       │ 23040   │
│ 2019 │ 3     │ 1       │ platinum │ 600   │ 25       │ 15000   │
│ 2019 │ 4     │ 2       │ silver   │ 60    │ 300      │ 18000   │
└──────┴───────┴─────────┴──────────┴───────┴──────────┴─────────┘
```
- `year`, `month`, `quarter` — год, месяц и квартал продажи;
- `plan` — тарифный план;
- `price` — стоимость одной подписки;
- `quantity` — количество проданных подписок по данному тарифу за месяц;
- `revenue` = price * quantity.

### 4.1.2 Сначала агрегация, затем окна
Чтобы составить отчет, данные часто приходится агрегировать. При этом на каком-то этапе должны отработать оконные функции. Как совместить агрегацию с окнами? Давайте разбираться.
Допустим, мы хотим посмотреть, как выручка за каждый год соотносится с выручкой за два года.
Сначала считаем агрегаты по годам:
```sql
select
  year,
  sum(revenue) as revenue
from sales
group by year;

┌──────┬─────────┐
│ year │ revenue │
├──────┼─────────┤
│ 2019 │ 722460  │
│ 2020 │ 1244940 │
└──────┴─────────┘
```
Теперь с помощью оконных функций считаем общую выручку на агрегированных результатах:
```sql
with data as (
  select
    year,
    sum(revenue) as revenue
  from sales
  group by year
)

select
  year,
  revenue,
  sum(revenue) over () as total
from data
order by year;

┌──────┬─────────┬─────────┐
│ year │ revenue │  total  │
├──────┼─────────┼─────────┤
│ 2019 │ 722460  │ 1967400 │
│ 2020 │ 1244940 │ 1967400 │
└──────┴─────────┴─────────┘
```
В простых случаях можно совместить оба запроса в один:
```sql
select
  year,
  sum(revenue) as revenue,
  sum(sum(revenue)) over () as total
from sales
group by year
order by year;

┌──────┬─────────┬─────────┐
│ year │ revenue │  total  │
├──────┼─────────┼─────────┤
│ 2019 │ 722460  │ 1967400 │
│ 2020 │ 1244940 │ 1967400 │
└──────┴─────────┴─────────┘
```
Принцип тот же самый. Сначала агрегируем данные, затем применяем «окошки» на результате.

### 4.1.3 Сначала окна, затем отсев
Допустим, мы хотим посмотреть, как соотносится месячная выручка по тарифам silver и gold.
Для начала, вытащим «серебряную» и «золотую» выручки в отдельные столбцы через `case`:
```sql
select
  month,
  (case when plan = 'silver' then revenue end) as silver,
  (case when plan = 'gold' then revenue end) as gold
from sales
where year = 2020 and plan in ('gold', 'silver')
order by month, plan;

┌───────┬────────┬───────┐
│ month │ silver │ gold  │
├───────┼────────┼───────┤
│ 1     │        │ 14400 │
│ 1     │ 27000  │       │
│ 2     │        │ 29040 │
│ 2     │ 61200  │       │
│ 3     │        │ 31200 │
│ 3     │ 42000  │       │
│ ...   │ ...    │ ...   │
└───────┴────────┴───────┘
```
Все хорошо, только нужные нам значения оказались в разных строчках: сначала всегда идет gold, затем silver. Подтянем показатель gold в строчку к silver с помощью функции `lag()`:
```sql
select
  month,
  (case when plan = 'silver' then revenue end) silver,
  lag(case when plan = 'gold' then revenue end) over w as gold
from sales
where year = 2020 and plan in ('gold', 'silver')
window w as (
  partition by month
  order by plan
)
order by month, plan;

┌───────┬────────┬───────┐
│ month │ silver │ gold  │
├───────┼────────┼───────┤
│ 1     │        │       │
│ 1     │ 27000  │ 14400 │
│ 2     │        │       │
│ 2     │ 61200  │ 29040 │
│ 3     │        │       │
│ 3     │ 42000  │ 31200 │
│ ...   │ ...    │ ...   │
└───────┴────────┴───────┘
```
Стало еще лучше. Теперь бы только убрать пустые строки из ответа.
Для этого поместим промежуточный запрос в табличное выражение и отфильтруем его:
```sql
with data as (
  select
    month,
    (case when plan = 'silver' then revenue end) silver,
    lag((case when plan = 'gold' then revenue end)) over w as gold
  from sales
  where year = 2020 and plan in ('gold', 'silver')
  window w as (
    partition by month
    order by plan
  )
)

select month, silver, gold
from data
where silver is not null;
```
Тем самым убрали строки, где в silver (а заодно gold) находятся значения `null`:
```sql
┌───────┬────────┬───────┐
│ month │ silver │ gold  │
├───────┼────────┼───────┤
│ 1     │ 27000  │ 14400 │
│ 2     │ 61200  │ 29040 │
│ 3     │ 42000  │ 31200 │
│ 4     │ 42000  │ 43200 │
│ 5     │ 39000  │ 34560 │
│ 6     │ 52800  │ 44880 │
│ 7     │ 46800  │ 40320 │
│ 8     │ 33000  │ 28800 │
│ 9     │ 54000  │ 28800 │
│ 10    │ 57000  │ 36000 │
│ 11    │ 62700  │ 51840 │
│ 12    │ 66000  │ 28800 │
└───────┴────────┴───────┘
```
Вот теперь хорошо!

### 4.1.4 Агрегация и null
Рассмотрим ту же задачу: узнать, как соотносится месячная выручка по тарифам silver и gold.
Вернемся к самому первому запросу, который вытаскивает «серебряную» и «золотую» выручки в отдельные столбцы через `case`:
```sql
select
  month,
  (case when plan = 'silver' then revenue end) as silver,
  (case when plan = 'gold' then revenue end) as gold
from sales
where year = 2020 and plan in ('gold', 'silver')
order by month, plan;

┌───────┬────────┬───────┐
│ month │ silver │ gold  │
├───────┼────────┼───────┤
│ 1     │        │ 14400 │
│ 1     │ 27000  │       │
│ 2     │        │ 29040 │
│ 2     │ 61200  │       │
│ 3     │        │ 31200 │
│ 3     │ 42000  │       │
│ ...   │ ...    │ ...   │
└───────┴────────┴───────┘
```
На предыдущем шаге мы использовали окна, чтобы подтянуть показатель gold в строчку к silver. Но можно обойтись и без них.
Идея следующая:
- поместим промежуточный запрос в табличное выражение;
- сгруппируем результаты по месяцам;
- для каждого месяца возьмем максимальное значение silver и gold.
```sql
with data as (
  select
    month,
    (case when plan = 'silver' then revenue end) as silver,
    (case when plan = 'gold' then revenue end) as gold
  from sales
  where year = 2020 and plan in ('gold', 'silver')
)

select
  month,
  max(silver) as silver,
  max(gold) as gold
from data
group by month
order by month;
```
Поскольку `max()` всегда выбирает не-null значение, он схлопывает две строчки по каждому месяцу в одну:
```sql
┌───────┬────────┬───────┐
│ month │ silver │ gold  │
├───────┼────────┼───────┤
│ 1     │ 27000  │ 14400 │
│ 2     │ 61200  │ 29040 │
│ 3     │ 42000  │ 31200 │
│ 4     │ 42000  │ 43200 │
│ 5     │ 39000  │ 34560 │
│ 6     │ 52800  │ 44880 │
│ 7     │ 46800  │ 40320 │
│ 8     │ 33000  │ 28800 │
│ 9     │ 54000  │ 28800 │
│ 10    │ 57000  │ 36000 │
│ 11    │ 62700  │ 51840 │
│ 12    │ 66000  │ 28800 │
└───────┴────────┴───────┘
```
Точно такой же результат, как на предыдущем шаге.
В простых случаях можно совместить оба запроса в один:
```sql
select
  month,
  max(case when plan = 'silver' then revenue end) as silver,
  max(case when plan = 'gold' then revenue end) as gold
from sales
where year = 2020 and plan in ('gold', 'silver')
group by month
order by month;
```
Итого, мы рассмотрели три приема:
- сначала агрегация, затем окна;
- сначала окна, затем отсев;
- агрегация для схлопывания null-значений.