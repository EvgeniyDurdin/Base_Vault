### 2.1.1 Оконная функция
Сначала отсортируем таблицу по убыванию зарплаты: 
```sql
select
  null as rank,
  name, department, salary
from employees
order by salary desc, id;

┌──────┬──────────┬────────────┬────────┐
│ rank │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│      │ Иван     │ it         │ 120    │
│      │ Леонид   │ it         │ 104    │
│      │ Марина   │ it         │ 104    │
│      │ Анна     │ sales      │ 100    │
│      │ Вероника │ sales      │ 96     │
│      │ Григорий │ sales      │ 96     │
│      │ Ксения   │ it         │ 90     │
│      │ Елена    │ it         │ 84     │
│      │ Борис    │ hr         │ 78     │
│      │ Дарья    │ hr         │ 70     │
└──────┴──────────┴────────────┴────────┘
```
Теперь пройдем от первой строчки до последней и проставим ранг каждой записи. Начнем с 1 и будем увеличивать ранг каждый раз, когда значение `salary` меньше, чем у предыдущей записи
Чтобы проставить ранг, достаточно на каждом шаге смотреть только на значения из столбца `salary`, выделенные синей рамкой. Назовем эти значения _окном_.
Попробуем описать содержимое окна словами:
1. Это значения столбца `salary`.
2. Они упорядочены от большего значения к меньшему.
Сформулируем то же самое на SQL:
```sql
window w as (order by salary desc)
```
- `window` — ключевое слово, которое показывает, что дальше будет определение окна;
- `w` — название окна (может быть любым);
- `(order by salary desc)` — описание окна («значения столбца `salary`, упорядоченные по убыванию»).
Задача — посчитать ранг по окну `w`. На SQL это записывается как `dense_rank() over w`.
`dense_rank()` — это _оконная функция_, которая считает ранг по указанному окну. Логика `dense_rank()` такая же, как была у нас при ручном подсчете — начать с 1 и увеличивать ранг каждый раз, когда очередное значение из окна отличается от предыдущего.
Добавим окно и оконную функцию в исходный запрос:
```sql
select
  dense_rank() over w as rank,
  name, department, salary
from employees
window w as (order by salary desc)
order by rank, id;

┌──────┬──────────┬────────────┬────────┐
│ rank │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│ 1    │ Иван     │ it         │ 120    │
│ 2    │ Леонид   │ it         │ 104    │
│ 2    │ Марина   │ it         │ 104    │
│ 3    │ Анна     │ sales      │ 100    │
│ 4    │ Вероника │ sales      │ 96     │
│ 4    │ Григорий │ sales      │ 96     │
│ 5    │ Ксения   │ it         │ 90     │
│ 6    │ Елена    │ it         │ 84     │
│ 7    │ Борис    │ hr         │ 78     │
│ 8    │ Дарья    │ hr         │ 70     │
└──────┴──────────┴────────────┴────────┘
```

Вот как движок выполняет такой запрос:
1. Берет таблицу, указанную в `from`.
2. Выбирает из нее все записи.
3. Для каждой записи рассчитывает значение `dense_rank()` с помощью окна `w`.
4. Сортирует результат как указано в `order by`.

Общий порядок выполнения запроса такой:
1. select
2. from
3. where
4. group by
5. having
6. window
7. order by

Конструкция `window` сама по себе ничего не делает с результатами запроса. Она только определяет окно, которое можно использовать (или не использовать) в запросе. Если убрать вызов `dense_rank()`, запрос отработает, как будто нет никаких окон:
```sql
select
  null as rank,
  name, department, salary
from employees
window w as (order by salary desc)
order by salary desc, id;

┌──────┬──────────┬────────────┬────────┐
│ rank │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│      │ Иван     │ it         │ 120    │
│      │ Леонид   │ it         │ 104    │
│      │ Марина   │ it         │ 104    │
│      │ Анна     │ sales      │ 100    │
│      │ Вероника │ sales      │ 96     │
│      │ Григорий │ sales      │ 96     │
│      │ Ксения   │ it         │ 90     │
│      │ Елена    │ it         │ 84     │
│      │ Борис    │ hr         │ 78     │
│      │ Дарья    │ hr         │ 70     │
└──────┴──────────┴────────────┴────────┘
```
Окно начинает работать только тогда, когда в `select` появляется оконная функция, которая его использует.
**Важно:** чтобы функция ранжирования гарантированно корректно отработала, в окне должна быть сортировка. Иначе порядок записей не определен.

#### Оконные запросы в СУБД Oracle и MS SQL Server
Ни Oracle, ни SQL Server не поддерживают конструкцию `window`. Чтобы заставить работать оконный запрос в этих СУБД, перенесите описание окна внутрь инструкции `over`.
Не так:
```sql
select
  dense_rank() over w as rank,
  name, department, salary
from employees
window w as (order by salary desc)
order by rank, id;
```
А так:
```sql
select
  dense_rank() over (
    order by salary desc
  ) as rank,
  name, department, salary
from employees
order by rank, id;
```

#### Несколько окон
Что делать, если понадобится использовать в запросе несколько окон? Просто перечислите их через запятую в разделе `window`:
```sql
select ...
from ...
where ...
window
  w1 as (...),
  w2 as (...),
  w3 as (...)
;
```
Например, выполним ранжирование сотрудников по зарплате в прямом и обратном порядке:
```sql
select
  dense_rank() over w1 as r_asc,
  dense_rank() over w2 as r_desc,
  name, salary
from employees
window
  w1 as (order by salary asc),
  w2 as (order by salary desc)
order by salary, id;

┌───────┬────────┬──────────┬────────┐
│ r_asc │ r_desc │   name   │ salary │
├───────┼────────┼──────────┼────────┤
│ 1     │ 8      │ Дарья    │ 70     │
│ 2     │ 7      │ Борис    │ 78     │
│ 3     │ 6      │ Елена    │ 84     │
│ 4     │ 5      │ Ксения   │ 90     │
│ 5     │ 4      │ Вероника │ 96     │
│ 5     │ 4      │ Григорий │ 96     │
│ 6     │ 3      │ Анна     │ 100    │
│ 7     │ 2      │ Леонид   │ 104    │
│ 7     │ 2      │ Марина   │ 104    │
│ 8     │ 1      │ Иван     │ 120    │
└───────┴────────┴──────────┴────────┘
```

### 2.1.2 Секции окна
Сначала отсортируем таблицу по департаментам, а внутри департамента — по убыванию зарплаты:
```sql
select
  null as rank,
  name, department, salary
from employees
order by department, salary desc, id;

┌──────┬──────────┬────────────┬────────┐
│ rank │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│      │ Борис    │ hr         │ 78     │
│      │ Дарья    │ hr         │ 70     │
│      │ Иван     │ it         │ 120    │
│      │ Леонид   │ it         │ 104    │
│      │ Марина   │ it         │ 104    │
│      │ Ксения   │ it         │ 90     │
│      │ Елена    │ it         │ 84     │
│      │ Анна     │ sales      │ 100    │
│      │ Вероника │ sales      │ 96     │
│      │ Григорий │ sales      │ 96     │
└──────┴──────────┴────────────┴────────┘
```

 Опишем словами то как мы хотим присвоить ранг:
1. Окно разбито на несколько независимых _секций_ — по одной на департамент.
2. Внутри секции записи упорядочены по убыванию зарплаты.

Сформулируем то же самое на SQL:
```sql
window w as (
  partition by department
  order by salary desc
)
```
- `partition by department` указывает, как следует разбить окно на секции;
- `order by salary desc` задает сортировку внутри секции.
Функция расчета ранга остается прежней — `dense_rank()`.
Добавим окно и оконную функцию в исходный запрос:
```sql
select
  dense_rank() over w as rank,
  name, department, salary
from employees
window w as (
  partition by department
  order by salary desc
)
order by department, rank, id;

┌──────┬──────────┬────────────┬────────┐
│ rank │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│ 1    │ Борис    │ hr         │ 78     │
│ 2    │ Дарья    │ hr         │ 70     │
├──────┼──────────┼────────────┼────────┤
│ 1    │ Иван     │ it         │ 120    │
│ 2    │ Леонид   │ it         │ 104    │
│ 2    │ Марина   │ it         │ 104    │
│ 3    │ Ксения   │ it         │ 90     │
│ 4    │ Елена    │ it         │ 84     │
├──────┼──────────┼────────────┼────────┤
│ 1    │ Анна     │ sales      │ 100    │
│ 2    │ Вероника │ sales      │ 96     │
│ 2    │ Григорий │ sales      │ 96     │
└──────┴──────────┴────────────┴────────┘
```

### 2.1.3 Группы
Для примера разобьем сотрудников на 3 группы по величине зарплаты:
- высокооплачиваемые,
- средние,
- низкооплачиваемые.

Сначала отсортируем таблицу по убыванию зарплаты:
```sql
select
  null as tile,
  name, department, salary
from employees
order by salary desc, id;

┌──────┬──────────┬────────────┬────────┐
│ tile │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│      │ Иван     │ it         │ 120    │
│      │ Леонид   │ it         │ 104    │
│      │ Марина   │ it         │ 104    │
│      │ Анна     │ sales      │ 100    │
│      │ Вероника │ sales      │ 96     │
│      │ Григорий │ sales      │ 96     │
│      │ Ксения   │ it         │ 90     │
│      │ Елена    │ it         │ 84     │
│      │ Борис    │ hr         │ 78     │
│      │ Дарья    │ hr         │ 70     │
└──────┴──────────┴────────────┴────────┘
```

Всего 10 записей, 3 группы — значит, две группы по 3 записи и одна 4 записи. Например, так:
```sql
┌──────┬──────────┬────────────┬────────┐
│ tile │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│      │ Иван     │ it         │ 120    │
│      │ Леонид   │ it         │ 104    │
│      │ Марина   │ it         │ 104    │
│      │ Анна     │ sales      │ 100    │
├──────┼──────────┼────────────┼────────┤
│      │ Вероника │ sales      │ 96     │
│      │ Григорий │ sales      │ 96     │
│      │ Ксения   │ it         │ 90     │
├──────┼──────────┼────────────┼────────┤
│      │ Елена    │ it         │ 84     │
│      │ Борис    │ hr         │ 78     │
│      │ Дарья    │ hr         │ 70     │
└──────┴──────────┴────────────┴────────┘
```

Чтобы провести границы между группами, придется анализировать все зарплаты, отсортированные по убыванию. Поэтому окно будет таким:
```sql
window w as (order by salary desc)
```
А вот функция потребуется другая — `ntile(n)`, где `n` — количество групп. В нашем случае:
```sql
select
  ntile(3) over w as tile,
  name, department, salary
from employees
window w as (order by salary desc)
order by salary desc, id;

┌──────┬──────────┬────────────┬────────┐
│ tile │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│ 1    │ Иван     │ it         │ 120    │
│ 1    │ Леонид   │ it         │ 104    │
│ 1    │ Марина   │ it         │ 104    │
│ 1    │ Анна     │ sales      │ 100    │
├──────┼──────────┼────────────┼────────┤
│ 2    │ Вероника │ sales      │ 96     │
│ 2    │ Григорий │ sales      │ 96     │
│ 2    │ Ксения   │ it         │ 90     │
├──────┼──────────┼────────────┼────────┤
│ 3    │ Елена    │ it         │ 84     │
│ 3    │ Борис    │ hr         │ 78     │
│ 3    │ Дарья    │ hr         │ 70     │
└──────┴──────────┴────────────┴────────┘
```
_(разделители между группами я добавил вручную для наглядности)_

`ntile(n)` разбивает все записи на `n` групп и возвращает номер группы для каждой записи. 
Если общее количество записей T не делится без остатка на количество групп N, то первые K групп из N будут на 1 строку больше, где K остаток от деления T/N.

`ntile()` всегда старается разбить данные так, чтобы группы были одинакового размера. Поэтому записи с одинаковым значением з/п вполне могут попасть в разные (соседние) группы:
```sql
select
  ntile(2) over w as tile,
  name, department, salary
from employees
window w as (order by salary desc, id)
order by salary desc, tile;

┌──────┬──────────┬────────────┬────────┐
│ tile │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│ 1    │ Иван     │ it         │ 120    │
│ 1    │ Леонид   │ it         │ 104    │
│ 1    │ Марина   │ it         │ 104    │
│ 1    │ Анна     │ sales      │ 100    │
│ 1    │ Вероника │ sales      │ 96     │ <-- (!)
├──────┼──────────┼────────────┼────────┤
│ 2    │ Григорий │ sales      │ 96     │ <-- (!)
│ 2    │ Ксения   │ it         │ 90     │
│ 2    │ Елена    │ it         │ 84     │
│ 2    │ Борис    │ hr         │ 78     │
│ 2    │ Дарья    │ hr         │ 70     │
└──────┴──────────┴────────────┴────────┘
```

### 2.1.4 Функции ранжирования
Оконные функции ранжирования:

|Функция|Описание|
|---|---|
|`row_number()`|порядковый номер строки|
|`dense_rank()`|ранг строки|
|`rank()`|тоже ранг, но с пропусками|
|`ntile(n)`|разбивает все строки на `n` групп и возвращает номер группы, в которую попала строка|

`dense_rank()` и `ntile()` мы уже разобрали.
`row_number()` нумерует строки в порядке, указанном в `order by`. Никаких неожиданностей.
`rank()` похож на `dense_rank()`, a разницу проще всего показать на примере.
```sql
select
  ••• over w as rank,
  name, department, salary
from employees
window w as (order by salary desc)
order by rank, id;
```
В одном случае вместо `•••` укажем `dense_rank()`, а в другом — `rank()`:

|rank|name    |department|salary|
|----|--------|----------|------|
   |1|Иван    |it        |   120|
   |2|Леонид  |it        |   104|
   |2|Марина  |it        |   104|
   |3|Анна    |sales     |   100| 
   |4|Вероника|sales     |    96|
   |4|Григорий|sales     |    96|
   |5|Ксения  |it        |    90| 
   |6|Елена   |it        |    84|
   |7|Борис   |hr        |    78|
   |8|Дарья   |hr        |    70|
`dense_rank()`

|rank|name    |department|salary|
|----|--------|----------|------|
   |1|Иван    |it        |   120|
   |2|Леонид  |it        |   104|
   |2|Марина  |it        |   104|
   |4|Анна    |sales     |   100|
   |5|Вероника|sales     |    96|
   |5|Григорий|sales     |    96|
   |7|Ксения  |it        |    90|
   |8|Елена   |it        |    84|
   |9|Борис   |hr        |    78|
  |10|Дарья   |hr        |    70|
`rank()`
`dense_rank()` назначает Анне третье место, а `rank()` — четвертое, потому что второе-третье уже заняты Леонидом и Мариной. Аналогично с Ксенией после Вероники и Григория. Вот и вся разница.