### 2.1.1 Оконная функция
Сначала отсортируем таблицу по убыванию зарплаты: 
```sql
select
  null as rank,
  name, department, salary
from employees
order by salary desc, id;

┌──────┬──────────┬────────────┬────────┐
│ rank │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│      │ Иван     │ it         │ 120    │
│      │ Леонид   │ it         │ 104    │
│      │ Марина   │ it         │ 104    │
│      │ Анна     │ sales      │ 100    │
│      │ Вероника │ sales      │ 96     │
│      │ Григорий │ sales      │ 96     │
│      │ Ксения   │ it         │ 90     │
│      │ Елена    │ it         │ 84     │
│      │ Борис    │ hr         │ 78     │
│      │ Дарья    │ hr         │ 70     │
└──────┴──────────┴────────────┴────────┘
```
Теперь пройдем от первой строчки до последней и проставим ранг каждой записи. Начнем с 1 и будем увеличивать ранг каждый раз, когда значение `salary` меньше, чем у предыдущей записи
Чтобы проставить ранг, достаточно на каждом шаге смотреть только на значения из столбца `salary`, выделенные синей рамкой. Назовем эти значения _окном_.
Попробуем описать содержимое окна словами:
1. Это значения столбца `salary`.
2. Они упорядочены от большего значения к меньшему.
Сформулируем то же самое на SQL:
```sql
window w as (order by salary desc)
```
- `window` — ключевое слово, которое показывает, что дальше будет определение окна;
- `w` — название окна (может быть любым);
- `(order by salary desc)` — описание окна («значения столбца `salary`, упорядоченные по убыванию»).
Задача — посчитать ранг по окну `w`. На SQL это записывается как `dense_rank() over w`.
`dense_rank()` — это _оконная функция_, которая считает ранг по указанному окну. Логика `dense_rank()` такая же, как была у нас при ручном подсчете — начать с 1 и увеличивать ранг каждый раз, когда очередное значение из окна отличается от предыдущего.
Добавим окно и оконную функцию в исходный запрос:
```sql
select
  dense_rank() over w as rank,
  name, department, salary
from employees
window w as (order by salary desc)
order by rank, id;

┌──────┬──────────┬────────────┬────────┐
│ rank │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│ 1    │ Иван     │ it         │ 120    │
│ 2    │ Леонид   │ it         │ 104    │
│ 2    │ Марина   │ it         │ 104    │
│ 3    │ Анна     │ sales      │ 100    │
│ 4    │ Вероника │ sales      │ 96     │
│ 4    │ Григорий │ sales      │ 96     │
│ 5    │ Ксения   │ it         │ 90     │
│ 6    │ Елена    │ it         │ 84     │
│ 7    │ Борис    │ hr         │ 78     │
│ 8    │ Дарья    │ hr         │ 70     │
└──────┴──────────┴────────────┴────────┘
```

Вот как движок выполняет такой запрос:
1. Берет таблицу, указанную в `from`.
2. Выбирает из нее все записи.
3. Для каждой записи рассчитывает значение `dense_rank()` с помощью окна `w`.
4. Сортирует результат как указано в `order by`.

Общий порядок выполнения запроса такой:
1. select
2. from
3. where
4. group by
5. having
6. window
7. order by

Конструкция `window` сама по себе ничего не делает с результатами запроса. Она только определяет окно, которое можно использовать (или не использовать) в запросе. Если убрать вызов `dense_rank()`, запрос отработает, как будто нет никаких окон:
```sql
select
  null as rank,
  name, department, salary
from employees
window w as (order by salary desc)
order by salary desc, id;

┌──────┬──────────┬────────────┬────────┐
│ rank │   name   │ department │ salary │
├──────┼──────────┼────────────┼────────┤
│      │ Иван     │ it         │ 120    │
│      │ Леонид   │ it         │ 104    │
│      │ Марина   │ it         │ 104    │
│      │ Анна     │ sales      │ 100    │
│      │ Вероника │ sales      │ 96     │
│      │ Григорий │ sales      │ 96     │
│      │ Ксения   │ it         │ 90     │
│      │ Елена    │ it         │ 84     │
│      │ Борис    │ hr         │ 78     │
│      │ Дарья    │ hr         │ 70     │
└──────┴──────────┴────────────┴────────┘
```
Окно начинает работать только тогда, когда в `select` появляется оконная функция, которая его использует.
**Важно:** чтобы функция ранжирования гарантированно корректно отработала, в окне должна быть сортировка. Иначе порядок записей не определен.

#### Оконные запросы в СУБД Oracle и MS SQL Server
Ни Oracle, ни SQL Server не поддерживают конструкцию `window`. Чтобы заставить работать оконный запрос в этих СУБД, перенесите описание окна внутрь инструкции `over`.
Не так:
```sql
select
  dense_rank() over w as rank,
  name, department, salary
from employees
window w as (order by salary desc)
order by rank, id;
```
А так:
```
select
  dense_rank() over (
    order by salary desc
  ) as rank,
  name, department, salary
from employees
order by rank, id;
```

#### Несколько окон
Что делать, если понадобится использовать в запросе несколько окон? Просто перечислите их через запятую в разделе `window`:
```sql
select ...
from ...
where ...
window
  w1 as (...),
  w2 as (...),
  w3 as (...)
;
```
Например, выполним ранжирование сотрудников по зарплате в прямом и обратном порядке:
```sql
select
  dense_rank() over w1 as r_asc,
  dense_rank() over w2 as r_desc,
  name, salary
from employees
window
  w1 as (order by salary asc),
  w2 as (order by salary desc)
order by salary, id;

┌───────┬────────┬──────────┬────────┐
│ r_asc │ r_desc │   name   │ salary │
├───────┼────────┼──────────┼────────┤
│ 1     │ 8      │ Дарья    │ 70     │
│ 2     │ 7      │ Борис    │ 78     │
│ 3     │ 6      │ Елена    │ 84     │
│ 4     │ 5      │ Ксения   │ 90     │
│ 5     │ 4      │ Вероника │ 96     │
│ 5     │ 4      │ Григорий │ 96     │
│ 6     │ 3      │ Анна     │ 100    │
│ 7     │ 2      │ Леонид   │ 104    │
│ 7     │ 2      │ Марина   │ 104    │
│ 8     │ 1      │ Иван     │ 120    │
└───────┴────────┴──────────┴────────┘
```

### 2.2.2 Секции окна
