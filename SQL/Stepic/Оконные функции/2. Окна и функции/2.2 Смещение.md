### 2.2.1 Сравнение с соседями
Упорядочим сотрудников по возрастанию зарплаты и проверим, велик ли разрыв между соседями.
Сначала отсортируем таблицу по возрастанию зарплаты:
```sql
select
  name, department, salary,
  null as prev
from employees
order by salary, id;

┌──────────┬────────────┬────────┬──────┐
│   name   │ department │ salary │ prev │
├──────────┼────────────┼────────┼──────┤
│ Дарья    │ hr         │ 70     │      │
│ Борис    │ hr         │ 78     │      │
│ Елена    │ it         │ 84     │      │
│ Ксения   │ it         │ 90     │      │
│ Вероника │ sales      │ 96     │      │
│ Григорий │ sales      │ 96     │      │
│ Анна     │ sales      │ 100    │      │
│ Леонид   │ it         │ 104    │      │
│ Марина   │ it         │ 104    │      │
│ Иван     │ it         │ 120    │      │
└──────────┴────────────┴────────┴──────┘
```
А чтобы на каждом шаге подтягивать зарплату предыдущего сотрудника, будем использовать оконную функцию `lag()`:
```sql
lag(salary, 1) over w
```
Функция `lag()` возвращает значение из указанного столбца, отстоящее от текущего на указанное количество записей назад. В нашем случае — `salary` от предыдущей записи.
Добавим окно и оконную функцию в исходный запрос:
```sql
select
  id, name, department, salary,
  lag(salary, 1) over w as prev
from employees
window w as (order by salary, id)
order by salary, id;
```

```sql
┌────┬──────────┬────────────┬────────┬──────┐
│ id │   name   │ department │ salary │ prev │
├────┼──────────┼────────────┼────────┼──────┤
│ 11 │ Дарья    │ hr         │ 70     │      │
│ 12 │ Борис    │ hr         │ 78     │ 70   │
│ 21 │ Елена    │ it         │ 84     │ 78   │
│ 22 │ Ксения   │ it         │ 90     │ 84   │
│ 31 │ Вероника │ sales      │ 96     │ 90   │
│ 32 │ Григорий │ sales      │ 96     │ 96   │
│ 33 │ Анна     │ sales      │ 100    │ 96   │
│ 23 │ Леонид   │ it         │ 104    │ 100  │
│ 24 │ Марина   │ it         │ 104    │ 104  │
│ 25 │ Иван     │ it         │ 120    │ 104  │
└────┴──────────┴────────────┴────────┴──────┘
```

Столбец `prev` показывает зарплату предыдущего сотрудника. Осталось посчитать разницу между `prev` и `salary` в процентах:

```sql
with emp as (
  select
    id, name, department, salary,
    lag(salary, 1) over w as prev
  from employees
  window w as (order by salary, id)
)
select
  name, department, salary,
  round((salary - prev)*100.0 / prev) as diff
from emp
order by salary, id;
```

```sql
┌──────────┬────────────┬────────┬──────┐
│   name   │ department │ salary │ diff │
├──────────┼────────────┼────────┼──────┤
│ Дарья    │ hr         │ 70     │      │
│ Борис    │ hr         │ 78     │ 11.0 │
│ Елена    │ it         │ 84     │ 8.0  │
│ Ксения   │ it         │ 90     │ 7.0  │
│ Вероника │ sales      │ 96     │ 7.0  │
│ Григорий │ sales      │ 96     │ 0.0  │
│ Анна     │ sales      │ 100    │ 4.0  │
│ Леонид   │ it         │ 104    │ 4.0  │
│ Марина   │ it         │ 104    │ 0.0  │
│ Иван     │ it         │ 120    │ 15.0 │
└──────────┴────────────┴────────┴──────┘
```

Можно избавиться от промежуточной таблицы `emp`, подставив вместо `prev` вызов оконной функции:

```sql
select
  name, department, salary,
  round(
    (salary - lag(salary, 1) over w)*100.0 / lag(salary, 1) over w
  ) as diff
from employees
window w as (order by salary, id)
order by salary, id;
```

Здесь мы заменили `prev` → `lag(salary, 1) over w`. Конструкцию вида `function_name(...) over window_name` движок заменяет на конкретное значение, которое вернула функция. Так что оконную функцию можно вызывать прямо внутри вычислений, и вы не раз встретите такие запросы в документации и примерах.

### 2.2.2 Сравнение с границами
Посмотрим, как зарплата сотрудника соотносится с минимальной и максимальной зарплатой в его департаменте
Окно состоит из трех секций. Секция на каждом шаге охватывает весь департамент сотрудника. Записи при этом упорядочены по возрастанию зарплаты внутри департамента, чтобы минимальная и максимальная зарплаты всегда находились на границах секции:
```sql
window w as (
  partition by department
  order by salary
)
```
Хотелось бы воспользоваться функциями `lag()` и `lead()`, чтобы получить диапазон зарплат в отделе. Но они заглядывают на фиксированное количество записей назад или вперед. Нам же требуется нечто другое:
- `low` — зарплата первого сотрудника, входящего в секцию окна;
- `high` — зарплата последнего сотрудника, входящего в секцию.
К счастью, есть оконные функции ровно для этого:
```sql
first_value(salary) over w as low,
last_value(salary) over w as high
```
Добавим окно и оконную функцию в исходный запрос:
```sql
select
  name, department, salary, 
  first_value(salary) over w as low,
  last_value(salary) over w as high
from employees
window w as (
  partition by department
  order by salary
)
order by department, salary, id;

┌──────────┬────────────┬────────┬─────┬──────┐
│   name   │ department │ salary │ low │ high │
├──────────┼────────────┼────────┼─────┼──────┤
│ Дарья    │ hr         │ 70     │ 70  │ 70   │
│ Борис    │ hr         │ 78     │ 70  │ 78   │
├──────────┼────────────┼────────┼─────┼──────┤
│ Елена    │ it         │ 84     │ 84  │ 84   │
│ Ксения   │ it         │ 90     │ 84  │ 90   │
│ Леонид   │ it         │ 104    │ 84  │ 104  │
│ Марина   │ it         │ 104    │ 84  │ 104  │
│ Иван     │ it         │ 120    │ 84  │ 120  │
├──────────┼────────────┼────────┼─────┼──────┤
│ Вероника │ sales      │ 96     │ 96  │ 96   │
│ Григорий │ sales      │ 96     │ 96  │ 96   │
│ Анна     │ sales      │ 100    │ 96  │ 100  │
└──────────┴────────────┴────────┴─────┴──────┘
```
`low` рассчитался корректно, а вот с `high` какая-то ерунда. Вместо того, чтобы равняться максимальной зарплате департамента, он меняется от сотрудника к сотруднику. Что ж, давайте разбираться.

### 2.2.3 Окно, секция, фрейм
До сих пор все было логично:
- есть окно, которое состоит из одной или нескольких секций;
- внутри секции записи упорядочены по конкретному столбцу.
На предыдущем шаге мы разделили окно на три секции — по департаментам, и упорядочили записи внутри секций по зарплате:
```sql
window w as (
  partition by department
  order by salary
)
```
Допустим, движок выполняет запрос, и текущая запись — Леонид из it-отдела. Мы ожидаем, что `first_value()` вернет первую запись it-секции (`salary = 84`), а `last_value()` — последнюю (`salary = 120`):
![[Stepic_Wnd_2.2.1.png]]
Вместо этого `last_value()` возвращает `salary = 104`:
![[Stepic_Wnd_2.2.2.png]]
Дело в том, что функции `first_value()` и `last_value()` работают не просто с секцией окна. Они работают с _фреймом_ внутри секции:
![[Stepic_Wnd_2.2.3.png]]
Фрейм находится в той же секции, где текущая запись (Леонид):
- начало фрейма = начало секции (Елена);
- конец фрейма = последняя запись со значением `salary`, равным текущей записи (Марина).
**Где заканчивается фрейм**
Если с началом фрейма все понятно, то с концом у людей часто возникают вопросы. Рассмотрим несколько примеров, чтобы стало понятнее.
```http
Елена    84  ← начало фрейма 
Ксения   90
Леонид  104  ← текущая запись
Марина  104  ← конец фрейма
Иван    120 
```
Конец фрейма — последняя запись со значением зарплаты, равным текущей записи. Текущая запись — Леонид с зарплатой 104. Последняя запись с зарплатой 104 — Марина. Значит, конец фрейма — Марина.
```http
Елена    84  ← начало фрейма 
Ксения   90
Леонид  104  ← текущая запись и конец фрейма
Марина  110
Иван    120 
```
Допустим, Марине повысили зарплату до 110. Текущая запись — Леонид с зарплатой 104. Последняя запись с зарплатой 104 — тоже Леонид. Значит, конец фрейма — Леонид.
```http
Елена    84  ← начало фрейма 
Ксения   90
Леонид  104  ← текущая запись
Марина  104
Иван    104  ← конец фрейма 
```
Допустим, Ивану понизили зарплату до 104. Текущая запись — Леонид с зарплатой 104. Последняя запись с зарплатой 104 — Иван. Значит, конец фрейма — Иван.
`first_value()` возвращает первую строчку фрейма, а не секции. Но поскольку начало фрейма совпадает с началом секции, функция отрабатывает как мы ожидали.
`last_value()` возвращает последнюю строчку фрейма, а не секции. Именно поэтому в нашем запросе она вернула не максимальную зарплату для каждого отдела, а какую-то ерунду.
Чтобы `last_value()` работала как мы ожидаем, придется «прибить» границы фрейма к границам секции. Тогда для каждой секции фрейм будет в точности совпадать с ней:
![[Stepic_Wnd_2.2.4.png]]
Подытожим принцип, по которому работают `first_value()` и `last_value()`:
1. Есть _окно_, которое состоит из одной или нескольких _секций_ (`partition by department`).
2. Внутри секции записи упорядочены по конкретному столбцу (`order by salary`).
3. У каждой записи в секции свой _фрейм_. По умолчанию начало фрейма совпадает с началом секции, а конец для каждой записи свой.
4. Конец фрейма можно приклеить к концу секции, чтобы фрейм в точности совпадал с секцией.
5. Функция `first_value()` возвращает значение из первой строки фрейма.
6. Функция `last_value()` возвращает значение из последней строки фрейма.
Теперь разберемся, как прибить фрейм к окну — и закончим с запросом по диапазону зарплат в департаментах.

### 2.2.4 Сравнение с границами, окончание
Возьмем наше окно:
```sql
window w as (
  partition by department
  order by salary
)
```
И настроим его, чтобы фрейм в точности совпадал с секцией (департаментом):
```sql
window w as (
  partition by department
  order by salary
  rows between unbounded preceding and unbounded following
)
```
Не будем сейчас разбирать конструкцию `rows between` — ее время придет на уроке про скользящие агрегаты. Важно, что благодаря ей фрейм совпадает с секцией, а значит `last_value()` вернет максимальную зарплату по департаменту:
```sql
select
  name, department, salary, 
  first_value(salary) over w as low,
  last_value(salary) over w as high
from employees
window w as (
  partition by department
  order by salary
  rows between unbounded preceding and unbounded following
)
order by department, salary, id;

┌──────────┬────────────┬────────┬─────┬──────┐
│   name   │ department │ salary │ low │ high │
├──────────┼────────────┼────────┼─────┼──────┤
│ Дарья    │ hr         │ 70     │ 70  │ 78   │
│ Борис    │ hr         │ 78     │ 70  │ 78   │
├──────────┼────────────┼────────┼─────┼──────┤
│ Елена    │ it         │ 84     │ 84  │ 120  │
│ Ксения   │ it         │ 90     │ 84  │ 120  │
│ Леонид   │ it         │ 104    │ 84  │ 120  │
│ Марина   │ it         │ 104    │ 84  │ 120  │
│ Иван     │ it         │ 120    │ 84  │ 120  │
├──────────┼────────────┼────────┼─────┼──────┤
│ Вероника │ sales      │ 96     │ 96  │ 100  │
│ Григорий │ sales      │ 96     │ 96  │ 100  │
│ Анна     │ sales      │ 100    │ 96  │ 100  │
└──────────┴────────────┴────────┴─────┴──────┘
```

### 2.2.5 Функции смещения
Оконные функции смещения:

|Функция|Описание|
|---|---|
|`lag(value, offset)`|значение `value` из строки, отстоящей на `offset` строк назад от текущей|
|`lead(value, offset)`|значение `value` из строки, отстоящей на `offset` строк вперед от текущей|
|`first_value(value)`|значение `value` из первой строки фрейма|
|`last_value(value)`|значение `value` из последней строки фрейма|
|`nth_value(value, n)`|значение `value` из `n`-й строки фрейма|

`lag()` и `lead()` действуют относительно текущей строки, заглядывая вперед или назад на указанное количество строк.
![[Stepic_Wnd_2.2.5.png]]
`first_value()`, `last_value()` и `nth_value()` действуют относительно границ фрейма, выбирая указанную строку в пределах фрейма.
![[Stepic_Wnd_2.2.6.png]]
Чтобы границы фрейма совпадали с границами секции (или всего окна, если секция одна) — используют конструкцию `rows between unbounded preceding and unbounded following` в определении окна.