### 2.4.1 Скользящее среднее
Судя по данным, доходы компании растут: 94К ₽ в январе → 104К ₽ в сентябре. А вот растут ли расходы? Сходу сложно сказать, месяц на месяц не приходится. Чтобы сгладить эти скачки, используют «скользящее среднее» — для каждого месяца рассчитывают средний расход с учетом предыдущего и следующего месяца. Например:
- скользящее среднее за февраль = (январь + февраль + март) / 3;
- за март = (февраль + март + апрель) / 3;
- за апрель = (март + апрель + май) / 3;
- и так далее.
Отсортируем таблицу по месяцам:
```sql
select
  year, month, expense,
  null as roll_avg
from expenses
order by year, month;

┌──────┬───────┬─────────┬──────────┐
│ year │ month │ expense │ roll_avg │
├──────┼───────┼─────────┼──────────┤
│ 2020 │ 1     │ 82      │          │
│ 2020 │ 2     │ 75      │          │
│ 2020 │ 3     │ 104     │          │
│ 2020 │ 4     │ 94      │          │
│ 2020 │ 5     │ 99      │          │
│ 2020 │ 6     │ 105     │          │
│ 2020 │ 7     │ 95      │          │
│ 2020 │ 8     │ 110     │          │
│ 2020 │ 9     │ 104     │          │
└──────┴───────┴─────────┴──────────┘
```
Рамка на каждом шаге сдвигается вниз, скользит — так и получается скользящее среднее. Чтобы описать на SQL, придется вспомнить концепцию фреймов, с которой мы познакомились на уроке о смещении:
1. Окно состоит из одной или нескольких секций (в нашем случае секция одна — все записи `expenses`).
2. Внутри секции записи упорядочены по конкретным столбцам (`order by year, month`).
3. У каждой записи свой фрейм.
Фрейм на каждом шаге охватывает три записи — текущую, предыдущую и следующую:
![[Stepic_Wnd_2.4.1.png]]
Вот как записать это на SQL:
```sql
window w as (
  order by year, month
  rows between 1 preceding and 1 following
)
```
С `order by` все понятно, а вторая строчка — это как раз определение фрейма: «выбрать строки от 1 предыдущей до 1 следующей». На следующем шаге разберемся с фреймами подробно, а пока закончим с нашим запросом.
Считаем среднее по расходам — это функция `avg()`:
```sql
avg(expense) over w
```
Добавим округление и сведем все вместе:
```sql
select
  year, month, expense,
  round(avg(expense) over w) as roll_avg
from expenses
window w as (
  order by year, month
  rows between 1 preceding and 1 following
)
order by year, month;

┌──────┬───────┬─────────┬──────────┐
│ year │ month │ expense │ roll_avg │
├──────┼───────┼─────────┼──────────┤
│ 2020 │ 1     │ 82      │ 79.0     │
│ 2020 │ 2     │ 75      │ 87.0     │
│ 2020 │ 3     │ 104     │ 91.0     │
│ 2020 │ 4     │ 94      │ 99.0     │
│ 2020 │ 5     │ 99      │ 99.0     │
│ 2020 │ 6     │ 105     │ 100.0    │
│ 2020 │ 7     │ 95      │ 103.0    │
│ 2020 │ 8     │ 110     │ 103.0    │
│ 2020 │ 9     │ 104     │ 107.0    │
└──────┴───────┴─────────┴──────────┘
```
Скользящее среднее по расходам готово!

### 2.4.2 Фрейм
В общем случае определение фрейма выглядит так:
```sql
rows between X preceding and Y following
```
Где `X` — количество строк перед текущей, а `Y` — количество строк после текущей:
![[Stepic_Wnd_2.4.2.png]]
Если указать вместо `X` или `Y` значение `unbounded` — это значит «граница секции»:
![[Stepic_Wnd_2.4.3.png]]
Если указать вместо `X preceding` или `Y following` значение `current row` — это значит «текущая запись»:
![[Stepic_Wnd_2.4.4.png]]
Фрейм никогда не выходит за границы секции, если столкнулся с ней — обрезается:
![[Stepic_Wnd_2.4.5.png]]

### 2.4.3 Сумма нарастающим итогом
Благодаря скользящему среднему, мы выяснили, что в `expenses` растут и доходы, и расходы. А как они соотносятся друг с другом? Хочется понять, находится ли компания «в плюсе» или «в минусе» с учетом всех заработанных и потраченных денег.
Причем важно понимать не на конец периода, а на каждый месяц. Потому что если в сентябре у компании все ОК, а в июне она ушла в минус — это потенциальная проблема (такую ситуацию называют «кассовым разрывом»).
Поэтому посчитаем доходы и расходы по месяцам нарастающим итогом (кумулятивно):
- кумулятивный доход за январь = январь;
- за февраль = январь + февраль;
- за март = январь + февраль + март;
- за апрель = январь + февраль + март + апрель;
- и так далее.
![[Stepic_Wnd_2.4.6.png]]
`t_income` показывает доходы нарастающим итогом, `t_expense` — расходы, а `t_profit` — прибыль.
```sql
t_profit = t_income - t_expense
```
Как рассчитать кумулятивные показатели?
Отсортируем таблицу по месяцам:
```sql
select
  year, month, income, expense,
  null as t_income,
  null as t_expense,
  null as t_profit
from expenses
order by year, month;

┌──────┬───────┬────────┬─────────┬──────────┬───────────┬──────────┐
│ year │ month │ income │ expense │ t_income │ t_expense │ t_profit │
├──────┼───────┼────────┼─────────┼──────────┼───────────┼──────────┤
│ 2020 │ 1     │ 94     │ 82      │          │           │          │
│ 2020 │ 2     │ 94     │ 75      │          │           │          │
│ 2020 │ 3     │ 94     │ 104     │          │           │          │
│ 2020 │ 4     │ 100    │ 94      │          │           │          │
│ 2020 │ 5     │ 100    │ 99      │          │           │          │
│ 2020 │ 6     │ 100    │ 105     │          │           │          │
│ 2020 │ 7     │ 100    │ 95      │          │           │          │
│ 2020 │ 8     │ 100    │ 110     │          │           │          │
│ 2020 │ 9     │ 104    │ 104     │          │           │          │
└──────┴───────┴────────┴─────────┴──────────┴───────────┴──────────┘
```
Рамка на каждом шаге охватывает строки от начала таблицы до текущей записи. Мы уже знаем, как сформулировать подходящий фрейм:
```sql
window w as (
  order by year, month
  rows between unbounded preceding and current row
)
```
Считаем сумму по доходам и расходам — это функция `sum()`:
```sql
sum(income) over w as t_income,
sum(expense) over w as t_expense,
```
Прибыль считаем как разницу между доходами и расходами:
```sql
(sum(income) over w) - (sum(expense) over w) as t_profit
```
Все вместе:
```sql
select
  year, month, income, expense,
  sum(income) over w as t_income,
  sum(expense) over w as t_expense,
  (sum(income) over w) - (sum(expense) over w) as t_profit
from expenses
window w as (
  order by year, month
  rows between unbounded preceding and current row
)
order by year, month;

┌──────┬───────┬────────┬─────────┬──────────┬───────────┬──────────┐
│ year │ month │ income │ expense │ t_income │ t_expense │ t_profit │
├──────┼───────┼────────┼─────────┼──────────┼───────────┼──────────┤
│ 2020 │ 1     │ 94     │ 82      │ 94       │ 82        │ 12       │
│ 2020 │ 2     │ 94     │ 75      │ 188      │ 157       │ 31       │
│ 2020 │ 3     │ 94     │ 104     │ 282      │ 261       │ 21       │
│ 2020 │ 4     │ 100    │ 94      │ 382      │ 355       │ 27       │
│ 2020 │ 5     │ 100    │ 99      │ 482      │ 454       │ 28       │
│ 2020 │ 6     │ 100    │ 105     │ 582      │ 559       │ 23       │
│ 2020 │ 7     │ 100    │ 95      │ 682      │ 654       │ 28       │
│ 2020 │ 8     │ 100    │ 110     │ 782      │ 764       │ 18       │
│ 2020 │ 9     │ 104    │ 104     │ 886      │ 868       │ 18       │
└──────┴───────┴────────┴─────────┴──────────┴───────────┴──────────┘
```
По `t_profit` видно, что дела у компании идут неплохо. В некоторых месяцах расходы превышают доходы, но благодаря накопленной «денежной подушке» кассового разрыва не происходит.

### 2.4.4 Фрейм по умолчанию
Возьмем запрос, который считает расходы нарастающим итогом:
```sql
select
  year, month, expense,
  sum(expense) over w as total
from expenses
window w as (
  order by year, month
  rows between unbounded preceding and current row
)
order by year, month;

┌──────┬───────┬─────────┬───────┐
│ year │ month │ expense │ total │
├──────┼───────┼─────────┼───────┤
│ 2020 │ 1     │ 82      │ 82    │
│ 2020 │ 2     │ 75      │ 157   │
│ 2020 │ 3     │ 104     │ 261   │
│ 2020 │ 4     │ 94      │ 355   │
│ 2020 │ 5     │ 99      │ 454   │
│ 2020 │ 6     │ 105     │ 559   │
│ 2020 │ 7     │ 95      │ 654   │
│ 2020 │ 8     │ 110     │ 764   │
│ 2020 │ 9     │ 104     │ 868   │
└──────┴───────┴─────────┴───────┘
```
И уберем из него определение фрейма:
```sql
select
  year, month, expense,
  sum(expense) over w as total
from expenses
window w as (
  order by year, month
)
order by year, month;
```
Ожидаем, что в `total` теперь всегда будет одно и то же число — суммарные расходы за 9 месяцев. А вместо этого видим вот что:
**Ожидание**
```sql
┌──────┬───────┬─────────┬───────┐
│ year │ month │ expense │ total │
├──────┼───────┼─────────┼───────┤
│ 2020 │ 1     │ 82      │ 868   │
│ 2020 │ 2     │ 75      │ 868   │
│ 2020 │ 3     │ 104     │ 868   │
│ 2020 │ 4     │ 94      │ 868   │
│ 2020 │ 5     │ 99      │ 868   │
│ 2020 │ 6     │ 105     │ 868   │
│ 2020 │ 7     │ 95      │ 868   │
│ 2020 │ 8     │ 110     │ 868   │
│ 2020 │ 9     │ 104     │ 868   │
└──────┴───────┴─────────┴───────┘
```
**Реальность**
```sql
┌──────┬───────┬─────────┬───────┐
│ year │ month │ expense │ total │
├──────┼───────┼─────────┼───────┤
│ 2020 │ 1     │ 82      │ 82    │
│ 2020 │ 2     │ 75      │ 157   │
│ 2020 │ 3     │ 104     │ 261   │
│ 2020 │ 4     │ 94      │ 355   │
│ 2020 │ 5     │ 99      │ 454   │
│ 2020 │ 6     │ 105     │ 559   │
│ 2020 │ 7     │ 95      │ 654   │
│ 2020 │ 8     │ 110     │ 764   │
│ 2020 │ 9     │ 104     │ 868   │
└──────┴───────┴─────────┴───────┘
```
Запрос без фрейма все равно посчитал кумулятивные расходы — в точности как запрос с фреймом. Как так?
Все дело в наличии сортировки в окне (`order by year, month`). Правило такое:
- если в окне есть `order by`,
- и используется функция агрегации,
- и не указано определение фрейма,
- то используется фрейм по умолчанию.
Фрейм по умолчанию в нашем запросе распространяется от первой до текущей записи. Поэтому результаты совпадают с запросом, где фрейм был указан явно (`rows between unbounded preceding and current row`).
Но так бывает не всегда. Поэтому я рекомендую указывать фрейм явно — по крайней мере пока не разберетесь досконально в разновидностях фреймов. Добавили в окно `order by` — добавьте сразу и фрейм.
Если убрать из окна `order by`, агрегат из скользящего превратится в обычный:
```sql
select
  year, month, expense,
  sum(expense) over () as total
from expenses
order by year, month;

┌──────┬───────┬─────────┬───────┐
│ year │ month │ expense │ total │
├──────┼───────┼─────────┼───────┤
│ 2020 │ 1     │ 82      │ 868   │
│ 2020 │ 2     │ 75      │ 868   │
│ 2020 │ 3     │ 104     │ 868   │
│ 2020 │ 4     │ 94      │ 868   │
│ 2020 │ 5     │ 99      │ 868   │
│ 2020 │ 6     │ 105     │ 868   │
│ 2020 │ 7     │ 95      │ 868   │
│ 2020 │ 8     │ 110     │ 868   │
│ 2020 │ 9     │ 104     │ 868   │
└──────┴───────┴─────────┴───────┘
```
Здесь без неожиданностей.