### 3.2.1 RANGE-фреймы
Последний тип фрейма — фрейм по диапазону:
```sql
RANGE BETWEEN frame_start AND frame_end
```
Если rows-фрейм оперирует строками, а groups — группами строк с одинаковыми значениями, то range — группами строк, которые попадают в диапазон. Например, возьмем такое окно:
```sql
window w as (
  order by salary
  range between 10 preceding and 10 following
)
```
Фрейм для записи со значением `salary = X` будет включать сотрудников с диапазоном зарплат от `X-10` до `X+10` включительно. Например, для Григория с зарплатой 96К ₽ — сотрудников с з/п от 86К до 106К ₽:
```sql
┌──────────┬────────┐
│   name   │ salary │
├──────────┼────────┤
│ Дарья    │ 70     │
│ Борис    │ 78     │
│ Елена    │ 84     │
│ Ксения   │ 90     │ -- начало фрейма
│ Вероника │ 96     │
│ Григорий │ 96     │ -- текущая запись
│ Анна     │ 100    │
│ Леонид   │ 104    │
│ Марина   │ 104    │ -- конец фрейма
│ Иван     │ 120    │
└──────────┴────────┘
```
Если рассчитать фрейм для каждой записи, получится так:
```sql
┌──────────┬────────┐
│   name   │ salary │ -- какую з/п включает фрейм
├──────────┼────────┤
│ Дарья    │ 70     │ -- 60-80   Дарья, Борис
│ Борис    │ 78     │ -- 68-88   Дарья, Борис, Елена
│ Елена    │ 84     │ -- 74-94   Борис, Елена, Ксения
│ Ксения   │ 90     │ -- 80-100  Елена, Ксения, Вероника, Григорий, Анна
│ Вероника │ 96     │ -- 86-106  Ксения, Вероника, Григорий, Анна, Леонид, Марина
│ Григорий │ 96     │ -- 86-106  Ксения, Вероника, Григорий, Анна, Леонид, Марина
│ Анна     │ 100    │ -- 90-110  Ксения, Вероника, Григорий, Анна, Леонид, Марина
│ Леонид   │ 104    │ -- 94-114  Вероника, Григорий, Анна, Леонид, Марина
│ Марина   │ 104    │ -- 94-114  Вероника, Григорий, Анна, Леонид, Марина
│ Иван     │ 120    │ -- 110-120 Иван
└──────────┴────────┘
```
Проверим — посчитаем количество сотрудников по каждому диапазону:
```sql
select
  name, salary,
  count(*) over w as cnt
from employees
window w as (
  order by salary
  range between 10 preceding and 10 following
)
order by salary, id;

┌──────────┬────────┬─────┐
│   name   │ salary │ cnt │
├──────────┼────────┼─────┤
│ Дарья    │ 70     │ 2   │ -- 60-80   Дарья, Борис
│ Борис    │ 78     │ 3   │ -- 68-88   Дарья, Борис, Елена
│ Елена    │ 84     │ 3   │ -- 74-94   Борис, Елена, Ксения
│ Ксения   │ 90     │ 5   │ -- 80-100  Елена, Ксения, Вероника, Григорий, Анна
│ Вероника │ 96     │ 6   │ -- 86-106  Ксения, Вероника, Григорий, Анна, Леонид, Марина
│ Григорий │ 96     │ 6   │ -- 86-106  Ксения, Вероника, Григорий, Анна, Леонид, Марина
│ Анна     │ 100    │ 6   │ -- 90-110  Ксения, Вероника, Григорий, Анна, Леонид, Марина
│ Леонид   │ 104    │ 5   │ -- 94-114  Вероника, Григорий, Анна, Леонид, Марина
│ Марина   │ 104    │ 5   │ -- 94-114  Вероника, Григорий, Анна, Леонид, Марина
│ Иван     │ 120    │ 1   │ -- 110-120 Иван
└──────────┴────────┴─────┘
```
Все сходится!
У диапазонных фреймов несколько особенностей:
**1. Только один столбец в order by**
Поскольку range-фрейм динамически рассчитывается по вхождению в диапазон `between .. and ..`, то в order by должен быть ровно один столбец. Так не получится:
```sql
window w as (
  order by salary, city
  range between 10 preceding and 10 following
)
```
**2. Только числа или даты для N preceding / following**
Условия `N preceding` и `N following` работают только для числовых столбцов и столбцов с датами. Например, такой фрейм лишен смысла:
```sql
window w as (
  order by department
  range between 10 preceding and 10 following
)
```
**3. current row — как у groups-фрейма**
Условие `current row` для range-фрейма работает так же, как для groups-фрейма — включает строки с одинаковым значением столбца из order by. Условия `unbounded preceding` и `unbounded following` для всех типов фреймов работают одинаково — включает строки от начала секции (unbounded preceding) и до конца секции (unbounded following).

### 3.2.2 Границы фрейма
Все типы фреймов — rows, groups и range — используют одни и те же инструкции, чтобы задать границы:
- unbounded preceding / following,
- N preceding / following,
- current row.
Но трактовка этих инструкций может отличаться в зависимости от типа фрейма.
Инструкции `unbounded preceding` и `unbounded following` всегда означают границы секции:
![[Stepic_Wnd_3.2.1.png]]
`current row` для строковых фреймов означает текущую запись, а для групповых и диапазонных — текущую запись и все равные ей (по значениям из order by):
![[Stepic_Wnd_3.2.2.png]]
`N preceding` и `N following` означают:
- для строковых фреймов — количество записей до / после текущей;
- для групповых фреймов — количество групп до / после текущей;
- для диапазонных фреймов — диапазон значений относительно текущей записи.
![[Stepic_Wnd_3.2.3.png]]

### 3.2.3 Фрейм по умолчанию
Возьмем запрос, который считает зарплату по организации нарастающим итогом:
```sql
select
  name, salary,
  sum(salary) over w as "sum"
from employees
window w as (
  order by salary
)
order by salary, id;

┌──────────┬────────┬─────┐
│   name   │ salary │ sum │
├──────────┼────────┼─────┤
│ Дарья    │ 70     │ 70  │
│ Борис    │ 78     │ 148 │
│ Елена    │ 84     │ 232 │
│ Ксения   │ 90     │ 322 │
│ Вероника │ 96     │ 514 │
│ Григорий │ 96     │ 514 │
│ Анна     │ 100    │ 614 │
│ Леонид   │ 104    │ 822 │
│ Марина   │ 104    │ 822 │
│ Иван     │ 120    │ 942 │
└──────────┴────────┴─────┘
```
Тут сразу возникает пара вопросов:
1. Мы не указали фрейм. Как тогда работает запрос?
2. Почему для Вероники и Григория (а также Леонида и Марины) показывается одинаковая сумма?
Ответ на оба вопроса один. Если фрейм не указан явно, используется такой:
```sql
RANGE BETWEEN unbounded preceding AND current row
```
Фрейм по умолчанию охватывает записи от начала секции до конца текущей группы (группа образована из записей с одинаковыми значениями order by). Вот как выглядят фреймы для Вероники и Леонида:
![[Stepic_Wnd_3.2.4.png]]
Выбор RANGE вместо ROWS в качестве фрейма по умолчанию может показаться странным. Глядя на запрос с суммой нарастающим итогом, никак не ожидаешь, что он посчитает одинаковую сумму для разных строчек. Поэтому я рекомендую не полагаться на фрейм по умолчанию и всегда явно указывать фрейм в запросе.
Все сказанное относится только к функциям, у которых фрейм настраивается:
- функции смещения `first_value()`, `last_value()`, `nth_value()`;
- все функции агрегации: `count()`, `avg()`, `sum()`, ...
У прочих функций фрейм всегда равен секции.