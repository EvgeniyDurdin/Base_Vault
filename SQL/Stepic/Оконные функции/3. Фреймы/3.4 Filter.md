### 3.4.1 FILTER
Продолжим работать с табличкой `employees`:
```sql
┌────┬──────────┬────────┬────────────┬────────┐
│ id │   name   │  city  │ department │ salary │
├────┼──────────┼────────┼────────────┼────────┤
│ 11 │ Дарья    │ Самара │ hr         │ 70     │
│ 12 │ Борис    │ Самара │ hr         │ 78     │
│ 21 │ Елена    │ Самара │ it         │ 84     │
│ 22 │ Ксения   │ Москва │ it         │ 90     │
│ 23 │ Леонид   │ Самара │ it         │ 104    │
│ 24 │ Марина   │ Москва │ it         │ 104    │
│ 25 │ Иван     │ Москва │ it         │ 120    │
│ 31 │ Вероника │ Москва │ sales      │ 96     │
│ 32 │ Григорий │ Самара │ sales      │ 96     │
│ 33 │ Анна     │ Москва │ sales      │ 100    │
└────┴──────────┴────────┴────────────┴────────┘
```
На прошлом уроке мы задавались вопросом, как изменится средняя зарплата, если уволить того или иного сотрудника. А теперь руководство размышляет: как изменится общий фонд оплаты труда, если кого-то одного уволить, а остальным зато поднять зарплату на 10%?
Что ж, это несложно посчитать:
```sql
select
  name, department, salary,
  sum(salary) over () as "база",
  sum(salary) over w as "+0%",
  sum(salary*1.1) over w as "+10%"
from employees
window w as (
  rows between unbounded preceding and unbounded following
  exclude current row
)
order by id;
```
- столбец `база` показывает ФОТ без увольнений;
- столбец `+0%` показывает ФОТ с увольнением без повышения з/п;
- столбец `+10%` показывает ФОТ с увольнением и повышением остальных з/п на 10%.
```sql
┌──────────┬────────────┬────────┬──────┬─────┬───────┐
│   name   │ department │ salary │ база │ +0% │ +10%  │
├──────────┼────────────┼────────┼──────┼─────┼───────┤
│ Дарья    │ hr         │ 70     │ 942  │ 872 │ 959.2 │
│ Борис    │ hr         │ 78     │ 942  │ 864 │ 950.4 │
│ Елена    │ it         │ 84     │ 942  │ 858 │ 943.8 │
│ Ксения   │ it         │ 90     │ 942  │ 852 │ 937.2 │
│ Леонид   │ it         │ 104    │ 942  │ 838 │ 921.8 │
│ Марина   │ it         │ 104    │ 942  │ 838 │ 921.8 │
│ Иван     │ it         │ 120    │ 942  │ 822 │ 904.2 │
│ Вероника │ sales      │ 96     │ 942  │ 846 │ 930.6 │
│ Григорий │ sales      │ 96     │ 942  │ 846 │ 930.6 │
│ Анна     │ sales      │ 100    │ 942  │ 842 │ 926.2 │
└──────────┴────────────┴────────┴──────┴─────┴───────┘
```
Пока директор думает, хватит ли денег на вариант «+10%», какая-то светлая голова предлагает — что если уволить всех айтишников, а остальным поднять аж на 50%? А ИТ можно на аутсорс отдать. Ох, заманчивый вариант, надо проверить.
Можно, конечно, сделать отдельный запрос с условием `department <> 'it'`, а затем соединить результат с предыдущим по `id` сотрудника. Но есть вариант проще — благодаря инструкции `FILTER`:
```sql
select
  ...
  sum(salary*1.5)
    filter(where department <> 'it')
    over () as "+50% без ИТ"
from employees
order by id;
```
FILTER работает как обычное условие WHERE, но фильтрует не все записи запроса, а только фрейм для конкретной оконной функции. В нашем случае — игнорирует сотрудников ИТ-департамента при подсчете суммарной зарплаты в столбце `+50% без ИТ`.
Запрос целиком и результат:
```sql
select
  name, department, salary,
  sum(salary) over () as "база",
  sum(salary) over w as "+0%",
  sum(salary*1.1) over w as "+10%",
  sum(salary*1.5)
    filter(where department <> 'it')
    over () as "+50% без ИТ"
from employees
window w as (
  rows between unbounded preceding and unbounded following
  exclude current row
)
order by id;

┌──────────┬────────────┬────────┬──────┬─────┬───────┬─────────────┐
│   name   │ department │ salary │ база │ +0% │ +10%  │ +50% без ИТ │
├──────────┼────────────┼────────┼──────┼─────┼───────┼─────────────┤
│ Дарья    │ hr         │ 70     │ 942  │ 872 │ 959.2 │ 660.0       │
│ Борис    │ hr         │ 78     │ 942  │ 864 │ 950.4 │ 660.0       │
│ Елена    │ it         │ 84     │ 942  │ 858 │ 943.8 │ 660.0       │
│ Ксения   │ it         │ 90     │ 942  │ 852 │ 937.2 │ 660.0       │
│ Леонид   │ it         │ 104    │ 942  │ 838 │ 921.8 │ 660.0       │
│ Марина   │ it         │ 104    │ 942  │ 838 │ 921.8 │ 660.0       │
│ Иван     │ it         │ 120    │ 942  │ 822 │ 904.2 │ 660.0       │
│ Вероника │ sales      │ 96     │ 942  │ 846 │ 930.6 │ 660.0       │
│ Григорий │ sales      │ 96     │ 942  │ 846 │ 930.6 │ 660.0       │
│ Анна     │ sales      │ 100    │ 942  │ 842 │ 926.2 │ 660.0       │
└──────────┴────────────┴────────┴──────┴─────┴───────┴─────────────┘
```
Вот это экономия!
FILTER поддерживается в PostgreSQL и SQLite, но не в Oracle, MySQL и SQL Server.

### 3.4.2 CASE как альтернатива FILTER
Вернемся к расчетам об увольнениях и повышениях. Поразмыслив, директор пришел к выводу, что увольнять весь ИТ-департамент — это чересчур. Теперь его интересует такой вариант:
- увольняем кого-то из сотрудников;
- остальным повышаем з/п на 10%;
- а айтишникам з/п не повышаем (и так большая).
Вопрос — как изменится фонд оплаты труда в этом случае?
Здесь не получится использовать FILTER, потому что он совсем отсеивает айтишников, а нам нужно учесть их зарплаты в ФОТ, но без 10% повышения. Придется воспользоваться вложенной конструкцией CASE:
```sql
select
  ...
  sum(
    case when department = 'it' then salary else salary*1.1 end
  ) over w as "+10% кроме ИТ"
from employees
window w as (...)
order by id;
```
Выражение `CASE` внутри `sum()` выдает обычную зарплату для айтишников и +10% для всех остальных — это именно то, что просил директор.
Запрос целиком и результат:
```sql
select
  name, department, salary,
  sum(salary) over () as "база",
  sum(salary) over w as "+0%",
  sum(salary*1.1) over w as "+10%",
  sum(
    case when department = 'it' then salary else salary*1.1 end
  ) over w as "+10% кроме ИТ"
from employees
window w as (
  rows between unbounded preceding and unbounded following
  exclude current row
)
order by id;

┌──────────┬────────────┬────────┬──────┬─────┬───────┬───────────────┐
│   name   │ department │ salary │ база │ +0% │ +10%  │ +10% кроме ИТ │
├──────────┼────────────┼────────┼──────┼─────┼───────┼───────────────┤
│ Дарья    │ hr         │ 70     │ 942  │ 872 │ 959.2 │ 909.0         │
│ Борис    │ hr         │ 78     │ 942  │ 864 │ 950.4 │ 900.2         │
│ Елена    │ it         │ 84     │ 942  │ 858 │ 943.8 │ 902.0         │
│ Ксения   │ it         │ 90     │ 942  │ 852 │ 937.2 │ 896.0         │
│ Леонид   │ it         │ 104    │ 942  │ 838 │ 921.8 │ 882.0         │
│ Марина   │ it         │ 104    │ 942  │ 838 │ 921.8 │ 882.0         │
│ Иван     │ it         │ 120    │ 942  │ 822 │ 904.2 │ 866.0         │
│ Вероника │ sales      │ 96     │ 942  │ 846 │ 930.6 │ 880.4         │
│ Григорий │ sales      │ 96     │ 942  │ 846 │ 930.6 │ 880.4         │
│ Анна     │ sales      │ 100    │ 942  │ 842 │ 926.2 │ 876.0         │
└──────────┴────────────┴────────┴──────┴─────┴───────┴───────────────┘
```
В общем случае конструкция CASE выглядит так:
```http
CASE
  WHEN условие1 THEN результат1
  WHEN условие2 THEN результат2
  ...
  WHEN условиеN THEN результатN
  ELSE результат_иначе
END
```
CASE — универсальный и более гибкий способ фильтрации записей фрейма, чем FILTER. К тому же его поддерживают все СУБД (в отличие от FILTER). Так что можно использовать FILTER в PostgreSQL и SQLite для простых ситуаций, а для более сложных или в других СУБД — CASE.